---
title: "Replication and Extension of Imbens & Xu (2024) Tutorial - LaLonde Males Samples" 
output: html_document
date: "2025-05-08"
---

# LaLonde (NSW) Data 
This section (4) examines the effect of the treatment (participation in the job training program) on the participants’ earnings in 1978 in the original LaLonde dataset (loaded as `nsw` below, similar to Imbens & Xu). 

For detailed explanations of the analysis steps and tips, please refer to section 2. Here, we only explain the nsw–specific results.

# Set up
## Source functions and load data
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# source functions
source("https://github.com/xuyiqing/lalonde/blob/main/tutorial/functions.R?raw=TRUE")
source("functions.R")
```

```{r}
# load data
load("data/lalonde.RData")
```

```{r}
# set seed
set.seed(42)
```

## Load and preprocess data (LaLonde (NSW))
```{r}
#| code-fold: show
treat <- "treat"
nsw_co$treat <- 1

# drop re74, u74, tau from CPS1 and PSID1 and merge data
cps1a <- subset(cps1, select =  -c(re74, u74))
nsw_cps <- rbind.data.frame(nsw_tr, cps1a)

psid1a <- subset(psid1, select =  -c(re74, u74))
nsw_psid <- rbind.data.frame(nsw_tr, psid1a)

nsw_cps_plus <- rbind.data.frame(nsw_cps, nsw_co)
nsw_psid_plus <- rbind.data.frame(nsw_psid, nsw_co)
```

# NSW
```{r}
#| code-fold: show
# define variables
Y <- "re78" 
treat <- "treat" 
covar <- c("age", "education", "black", "hispanic", "married", 
           "nodegree", "re75", "u75")
```

## Assessing overlap and covariate balance
### Overlap
```{r, class.source = "fold-show", fig.cap='FIGURE1. SubfigureA:NSW-Experimental. SubfigureB:NSW-CPS1. SubfigureC:NSW-PSID1.',out.width='100%', fig.asp=0.5}
#| code-fold: show
# assess overlap
nsw.ps <- assess_overlap(data = nsw, treat = treat, cov = covar)
nsw_cps.ps <- assess_overlap(data = nsw_cps, treat = treat, cov = covar) 
nsw_psid.ps <- assess_overlap(data = nsw_psid, treat = treat, cov = covar) 
```

As anticipated, the NSW-Experimental data exhibit an almost perfect overlap. In contrast, the observational datasets NSW-CPS1 and NSW-PSID1 display weak overlap. 

```{r, class.source = "fold-show", fig.cap='FIGURE2. SubfigureA:NSW-CPS1-PLUS. SubfigureD:NSW-PSID1-PLUS.', out.width='80%', fig.asp=1, fig.align='center'}
#| code-fold: show
# assess overlap
nsw_cps_plus.ps <- assess_overlap(data = nsw_cps_plus, treat = treat, cov = covar) 
nsw_psid_plus.ps <- assess_overlap(data = nsw_psid_plus, treat = treat, cov = covar) 
```

With the expanded datasets NSW-CPS1 and NSW-PSID1, it is evident that the degree of overlap between treated and control groups has improved, as seen by a greater spread of log-odds densities across both samples.

```{r}
#| code-fold: show
# set model formula
model <- as.formula(paste(treat, "~", paste(covar, collapse = " + ")))
```

### Covariate balance
```{r, message=FALSE, warning=FALSE}
love.plot(nsw, nsw_cps, treat, covar = covar, title = "NSW-CPS1")
love.plot(nsw, nsw_cps_plus, treat, covar = covar, title = "NSW-CPS1-PLUS")
love.plot(nsw, nsw_psid, treat, covar = covar, title = "NSW-PSID1")
love.plot(nsw, nsw_psid_plus, treat, covar = covar, title = "NSW-PSID1-PLUS")

bal.tab(model, data = nsw_cps, treat = "treat")
bal.tab(model, data = nsw_cps_plus, treat = "treat")
bal.tab(model, data = nsw_psid, treat = "treat")
bal.tab(model, data = nsw_psid_plus, treat = "treat")
```

Neither NSW-CPS1-PLUS nor NSW-PSID1-PLUS shows consistently improved covariate balance compared with their non-plus counterparts based on raw standardized differences. Although some specific covariates improve slightly, most show the same or increased imbalance.

In the subsequent analysis, that is focused on improving covariate balance and overlap, only the two datasets NSW-CPS1-PLUS and NSW-PSID1-PLUS are used. The NSW-Experimental data is excluded from these steps, as randomization already ensures adequate covariate balance and overlap. 

## Improving primarily covariate balance
### Matching 
#### Distance Matching
##### 1:1 Nearest neighbor matching
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# perform nearest neighbor matching with k=1, logistic propensity score and replacement
m.out.cps_plus.nearest <- matchit(model, data = nsw_cps_plus, method = "nearest", distance = "logit", replace = TRUE)
m.out.psid_plus.nearest <- matchit(model, data = nsw_psid_plus, method = "nearest", distance = "logit", replace = TRUE)
```

##### k:1 matching (k=2)
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
k<-2
# perform nearest neighbor matching with k=2, logistic propensity score and replacement
m.out.cps_plus.k2 <- matchit(model, data = nsw_cps_plus, method = "nearest", distance = "logit", ratio = k, replace = TRUE)
m.out.psid_plus.k2 <- matchit(model, data = nsw_psid_plus, method = "nearest", distance = "logit", ratio = k, replace = TRUE)
```

##### k:1 matching (k=3)
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
k<-3
# perform nearest neighbor matching with k=3, logistic propensity score and replacement
m.out.cps_plus.k3 <- matchit(model, data = nsw_cps_plus, method = "nearest", distance = "logit", ratio = k, replace = TRUE)
m.out.psid_plus.k3 <- matchit(model, data = nsw_psid_plus, method = "nearest", distance = "logit", ratio = k, replace = TRUE)
```

##### Caliper matching
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# perform nearest neighbor matching with a caliper of 0.1 on the logistic propensity score 
m.out.cps_plus.caliper <- matchit(model, data = nsw_cps_plus, method = "nearest", distance = "logit", caliper = 0.1, replace = TRUE)
m.out.psid_plus.caliper <- matchit(model, data = nsw_psid_plus, method = "nearest", distance = "logit", caliper = 0.1, replace = TRUE)
```

##### Common support restriction matching
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# perform nearest neighbor matching with exclusion of units outside common support
m.out.cps_plus.cs <- matchit(model, data = nsw_cps_plus, method = "nearest", distance = "logit", discard = "both", replace = TRUE)
m.out.psid_plus.cs <- matchit(model, data = nsw_psid_plus, method = "nearest", distance = "logit", discard = "both", replace = TRUE)
```

##### Mahalanobis distance matching (mahvars) 
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# perform nearest neighbor matching using mahalanobis distance on selected covariates
m.out.cps_plus.mahvars <- matchit(model, data = nsw_cps_plus, method = "nearest", distance = "logit", caliper = 0.2, mahvars = ~ age + education + re75, replace = FALSE)
m.out.psid_plus.mahvars <- matchit(model, data = nsw_psid_plus, method = "nearest", distance = "logit", caliper = 0.2, mahvars = ~ age + education + re75, replace = FALSE)
```

##### Optimal pair matching
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# perform optimal pair matching that minimizes total within-pair distance on propensity scores
m.out.cps_plus.optimal_pair <- matchit(model, data = nsw_cps_plus, method = "optimal", distance = "logit")
m.out.psid_plus.optimal_pair <- matchit(model, data = nsw_psid_plus, method = "optimal", distance = "logit")
```

##### Optimal full matching
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# perform optimal full matching allowing sets with varying ratios of treated to controls and minimizing a global distance criterion
m.out.cps_plus.optimal_full <- matchit(model, data = nsw_cps_plus, method = "full", distance = "logit")
m.out.psid_plus.optimal_full <- matchit(model, data = nsw_psid_plus, method = "full", distance = "logit")
```

##### Generalized full matching
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# perform generalized full matching using fast approximation and producing matched sets with flexible treated/control ratios 
m.out.cps_plus.general_full <- matchit(model, data = nsw_cps_plus, method = "quick", distance = "logit")
m.out.psid_plus.general_full <- matchit(model, data = nsw_psid_plus, method = "quick", distance = "logit")
```

##### Genetic matching
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# perform genetic matching 
m.out.cps_plus.genetic <- matchit(model, data = nsw_cps_plus, method = "genetic", distance = "logit", replace = TRUE, pop.size = 100)
m.out.psid_plus.genetic <- matchit(model, data = nsw_psid_plus, method = "genetic", distance = "logit", replace = TRUE, pop.size = 100)
```

#### Stratum matching
##### Exact matching (exact)
Strata = unique covariate profiles (raw covariates)
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# match units exactly by raw covariate profiles 
m.out.cps_plus.exact <- matchit(model, data = nsw_cps_plus, method = "exact")
m.out.psid_plus.exact <- matchit(model, data = nsw_psid_plus, method = "exact")
```

##### Coarsened matching (cem)
Strata = coarsened versions of covariates
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# match units exactly within coarse strata 
m.out.cps_plus.cem <- matchit(model, data = nsw_cps_plus, method = "cem")
m.out.psid_plus.cem <- matchit(model, data = nsw_psid_plus, method = "cem")
```

##### Subclassification 
Strata = bins of the propensity score
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# partition sample into fixed number of bins based on propensity score 
m.out.cps_plus.subcl <- matchit(model, data = nsw_cps_plus, method = "subclass", subclass = 5)
m.out.psid_plus.subcl <- matchit(model, data = nsw_psid_plus, method = "subclass", subclass = 5)
```

#### Pure subset selection
##### Cardinality profile matching
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# select largest balanced subsample meeting covariate balance tolerances
m.out.cps_plus.card <- matchit(model, data = nsw_cps_plus, method = "cardinality", tols = 0.1, ratio = 1)
m.out.psid_plus.card <- matchit(model, data = nsw_psid_plus, method = "cardinality", tols = 0.1, ratio = 1)
```

##### Profile matching
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# matching by directly optimizing balance profile measures across covariates
m.out.cps_plus.profile <- matchit_profile(nsw_cps_plus, treat, covar)
m.out.psid_plus.profile <- matchit_profile(nsw_psid_plus, treat, covar)
```

### Weighting
#### Inverse probability weights (IPW)
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# compute weights as inverse of estimated propensity scores 
w.out.cps_plus.ipw <- weightit(model, data = nsw_cps_plus, method = "ps", estimand = "ATT")
w.out.psid_plus.ipw <- weightit(model, data = nsw_psid_plus, method = "ps", estimand = "ATT")

nsw_cps_plus$ipw_weight <- w.out.cps_plus.ipw$weights
nsw_psid_plus$ipw_weight <- w.out.psid_plus.ipw$weights
```

#### Standardized mortality ratio (SMR) treated weights
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# calculate weights for ATT by assigning weight = 1 to treated units and weights proportional to odds of treatment for control
nsw_cps_plus$smr_weight <- create_smr_weights(nsw_cps_plus, model, "ATT")
nsw_psid_plus$smr_weight <- create_smr_weights(nsw_psid_plus, model, "ATT")
```

#### Matching weights
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# derive optimal matching weights intending to minimize covariate imbalance while targeting ATT
w.out.cps_plus.opt <- weightit(model, data = nsw_cps_plus, method = "optweight", estimand = "ATT")
w.out.psid_plus.opt <- weightit(model, data = nsw_psid_plus, method = "optweight", estimand = "ATT")

nsw_cps_plus$opt_weight <- w.out.cps_plus.opt$weights
nsw_psid_plus$opt_weight <- w.out.psid_plus.opt$weights
```

#### Overlap weights
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# calculate overlap weights emphasizing units with propensity scores near 0.5
nsw_cps_plus$overlap_weight <- create_overlap_weights(nsw_cps_plus, model)
nsw_psid_plus$overlap_weight <- create_overlap_weights(nsw_psid_plus, model)
```

#### Entropy weights
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# compute entropy balancing weights 
w.out.cps_plus.ebal <- weightit(model, data = nsw_cps_plus, method = "ebal", estimand = "ATT")
w.out.psid_plus.ebal <- weightit(model, data = nsw_psid_plus, method = "ebal", estimand = "ATT")

nsw_cps_plus$ebal_weight <- w.out.cps_plus.ebal$weights
nsw_psid_plus$ebal_weight <- w.out.psid_plus.ebal$weights
```

## Improving primarily overlap
### Truncation
```{r}
#| code-fold: show
# list of weight columns to apply truncation 
weight_columns <- c("ipw_weight", "smr_weight", "opt_weight", "overlap_weight", "ebal_weight")
```

#### Fixed maximum value truncation
```{r}
#| code-fold: show
# truncate weights by imposing a maximum threshold of 10
nsw_cps_plus.fixed <- nsw_cps_plus
for (wcol in weight_columns) {
  if (wcol %in% names(nsw_cps_plus.fixed)) {
    nsw_cps_plus.fixed <- truncate_weights_fixed(nsw_cps_plus.fixed, weight_col = wcol, max_weight = 10)
  }
}

nsw_psid_plus.fixed <- nsw_psid_plus
for (wcol in weight_columns) {
  if (wcol %in% names(nsw_psid_plus.fixed)) {
    nsw_psid_plus.fixed <- truncate_weights_fixed(nsw_psid_plus.fixed, weight_col = wcol, max_weight = 10)
  }
}
```

#### At percentile truncation
```{r}
#| code-fold: show
# truncate weights such that values above the 99th percentile are capped
nsw_cps_plus.percent <- nsw_cps_plus
for (wcol in weight_columns) {
  if (wcol %in% names(nsw_cps_plus.percent)) {
    nsw_cps_plus.percent <- truncate_weights_percentile(nsw_cps_plus.percent, weight_col = wcol, percentile = 0.99)
  }
}

nsw_psid_plus.percent <- nsw_psid_plus
for (wcol in weight_columns) {
  if (wcol %in% names(nsw_psid_plus.percent)) {
    nsw_psid_plus.percent <- truncate_weights_percentile(nsw_psid_plus.percent, weight_col = wcol, percentile = 0.99)
  }
}
```

#### Adaptive weight truncation
```{r}
#| code-fold: sh
# inspect variance of weights 
for (wcol in weight_columns) {
  if (wcol %in% names(nsw_cps_plus)) {
    check_weights(nsw_cps_plus, wcol)
  } else {
    cat("Column", wcol, "not found in nsw_cps.plus\n")
  }
}

for (wcol in weight_columns) {
  if (wcol %in% names(nsw_psid_plus)) {
    check_weights(nsw_psid_plus, wcol)
  } else {
    cat("Column", wcol, "not found in nsw_cps.plus\n")
  }
}
```

Regarding these results we only apply adaptive weight truncation to `ipw, smr, overlap` and `ebal` weights, where it may help mitigate the influence of extreme weights. 
```{r}
#| code-fold: show
# list weights that are valid 
weight_columns_at <- c("ipw_weight", "smr_weight", "overlap_weight", "ebal_weight")
```

```{r}
#| code-fold: show
# truncate adaptively at mean + 3 standard deviations 
nsw_cps_plus.adapt <- nsw_cps_plus
for (wcol in weight_columns_at) {
  if (wcol %in% names(nsw_cps_plus.adapt)) {
    nsw_cps_plus.adapt <- truncate_weights_adaptive(nsw_cps_plus.adapt, weight_col = wcol, c = 3)
  }
}

nsw_psid_plus.adapt <- nsw_psid_plus
for (wcol in weight_columns) {
  if (wcol %in% names(nsw_psid_plus.adapt)) {
    nsw_psid_plus.adapt <- truncate_weights_adaptive(nsw_psid_plus.adapt, weight_col = wcol, c = 3)
  }
}
```

### Trimming 
#### Propensity score threshold trimming (analogous to tutorial of Imbens & Xu (2024))
```{r}
#| code-fold: show
# apply trimming with thresholds 0.85 
nsw_cps_trim <- ps_trim(nsw_cps_plus.ps, threshold = 0.85)
nsw_psid_trim <- ps_trim(nsw_psid_plus.ps, threshold = 0.85)

# exclude experimental controls, subset trimmed data appropriately
nsw_cps.trim_match <- subset(nsw_cps_trim, sample %in% c(0,3) & ps_assoverlap)
nsw_psid.trim_match <- subset(nsw_psid_trim, sample %in% c(0,4) & ps_assoverlap)

# re-assign treat variable for controls in sample 3 or 4 (non-treated group)
nsw_cps.trim_match$treat[nsw_cps.trim_match$sample == 0.5] <- 0
nsw_psid.trim_match$treat[nsw_psid.trim_match$sample == 0.5] <- 0

# re-estimate propensity scores on trimmed data and perform 1:1 matching
nsw_cps.trim_match <- psmatch(data = nsw_cps.trim_match, Y = "re78", treat = "treat", cov = covar)
nsw_psid.trim_match <- psmatch(data = nsw_psid.trim_match, Y = "re78", treat = "treat", cov = covar)
```

#### Common range trimming
```{r}
#| code-fold: show
# trim observations outside the common support region of propensity scores
nsw_cps_plus.common   <- common_range_trim(nsw_cps_plus.ps)
nsw_psid_plus.common  <- common_range_trim(nsw_psid_plus.ps)
```

#### Propensity score trimming (Crump)
```{r}
#| code-fold: show
# trim observations with propensity scores outside [0.1, 0.9] interval
nsw_cps_plus.crump  <- crump_trim(nsw_cps_plus.ps, lower = 0.1, upper = 0.9)
nsw_psid_plus.crump <- crump_trim(nsw_psid_plus.ps, lower = 0.1, upper = 0.9)
```

#### Stuermer trimming
```{r}
#| code-fold: show
# trim observations based on propensity score quantiles separately for treated and control
nsw_cps_plus.stuermer  <- stuermer_trim(nsw_cps_plus.ps)
nsw_psid_plus.stuermer <- stuermer_trim(nsw_psid_plus.ps)
```

#### Walker trimming
```{r}
#| code-fold: show
# trim observations based on preference scores that adjust for treatment prevalence using logit transformations
nsw_cps_plus.walker   <- walker_trim(nsw_cps_plus.ps)
nsw_psid_plus.walker  <- walker_trim(nsw_psid_plus.ps)
```

### Combination of methods
```{r}
#| code-fold: show
# list trimming methods
trim_names <- c("ps_threshold", "common_range", "stuermer", "walker", "crump")
trimmed_cps  <- list(ps_threshold = nsw_cps_trim, common_range = nsw_cps_plus.common, stuermer = nsw_cps_plus.stuermer, walker = nsw_cps_plus.walker, crump = nsw_cps_plus.crump)
trimmed_psid <- list(ps_threshold = nsw_psid_trim, common_range = nsw_psid_plus.common, stuermer = nsw_psid_plus.stuermer, walker = nsw_psid_plus.walker, crump = nsw_psid_plus.crump)
```

#### IPW with 1) propensity threshold 2) common range 3) stuermer 4) walker 5) crump
```{r}
# apply inverse probability weighting (IPW) with trimming and attach IPW weights
ipw_comb.cps_plus <- setNames(
  lapply(trim_names, function(nm) trim_attach_weights(trimmed_cps[[nm]], nsw_cps_plus, "ipw_weight")),
  trim_names
)
ipw_comb.psid_plus <- setNames(
  lapply(trim_names, function(nm) trim_attach_weights(trimmed_psid[[nm]], nsw_psid_plus, "ipw_weight")),
  trim_names
)
```

#### SMR treated weights with 1) propensity threshold 2) common range 3) stuermer 4) walker 5) crump
```{r}
#| code-fold: show
# apply standardized mortality ratio (SMR) weighting with trimming and attach SMR weights
smr_treat_comb.cps_plus <- setNames(
  lapply(trim_names, function(nm) trim_attach_weights(trimmed_cps[[nm]], nsw_cps_plus, "smr_weight")),
  trim_names
)
smr_treat_comb.psid_plus <- setNames(
  lapply(trim_names, function(nm) trim_attach_weights(trimmed_psid[[nm]], nsw_psid_plus, "smr_weight")),
  trim_names
)
```

#### Overlap weights with 1) propensity threshold 2) common range 3) stuermer 4) walker 5) crump
```{r}
#| code-fold: show
# apply overlap weighting with trimming and attach overlap weights
ov_comb.cps_plus <- setNames(
  lapply(trim_names, function(nm) trim_attach_weights(trimmed_cps[[nm]], nsw_cps_plus, "overlap_weight")),
  trim_names
)
ov_comb.psid_plus <- setNames(
  lapply(trim_names, function(nm) trim_attach_weights(trimmed_psid[[nm]], nsw_psid_plus, "overlap_weight")),
  trim_names
)
```

#### Entropy weights with 1) propensity threshold 2) common range 3) stuermer 4) walker 5) crump
```{r}
#| code-fold: show
# apply entropy balancing weights with trimming and attach entropy weights
entropy_comb.cps_plus <- setNames(
  lapply(trim_names, function(nm) trim_attach_weights(trimmed_cps[[nm]], nsw_cps_plus, "ebal_weight")),
  trim_names
)
entropy_comb.psid_plus <- setNames(
  lapply(trim_names, function(nm) trim_attach_weights(trimmed_psid[[nm]], nsw_psid_plus, "ebal_weight")),
  trim_names
)
```

## Reassessing methods
### Matching
```{r}
#| code-fold: show
# list all matching methods
methods.cps_plus <- list(
  nn = m.out.cps_plus.nearest,
  k2 = m.out.cps_plus.k2,
  k3 = m.out.cps_plus.k3,
  caliper = m.out.cps_plus.caliper,
  cS = m.out.cps_plus.cs,
  mahvars = m.out.cps_plus.mahvars,
  optimal_pair = m.out.cps_plus.optimal_pair,
  optimal_full = m.out.cps_plus.optimal_full,
  gen_full = m.out.cps_plus.general_full,
  genetic = m.out.cps_plus.genetic,
  exact = m.out.cps_plus.exact,
  cem = m.out.cps_plus.cem,
  card = m.out.cps_plus.card,
  profile = m.out.cps_plus.profile,
  subcl = m.out.cps_plus.subcl
)

methods.psid_plus <- list(
  nn = m.out.psid_plus.nearest,
  k2 = m.out.psid_plus.k2,
  k3 = m.out.psid_plus.k3,
  caliper = m.out.psid_plus.caliper,
  cs = m.out.psid_plus.cs,
  mahvars = m.out.psid_plus.mahvars,
  optimal_pair = m.out.psid_plus.optimal_pair,
  optimal_full = m.out.psid_plus.optimal_full,
  gen_full = m.out.psid_plus.general_full,
  genetic = m.out.psid_plus.genetic,
  exact = m.out.psid_plus.exact,
  cem = m.out.psid_plus.cem,
  card = m.out.psid_plus.card,
  profile = m.out.psid_plus.profile,
  subcl = m.out.psid_plus.subcl
)
```

```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# calculate balance statistics 
bal.cps_plus <- cobalt::bal.tab(model, data = nsw_cps_plus, un = TRUE, weights = methods.cps_plus, s.d.denom = "treated")
bal.psid_plus <- cobalt::bal.tab(model, data = nsw_psid_plus, un = TRUE, weights = methods.psid_plus, s.d.denom = "treated")
```

#### SMD
```{r}
#| code-fold: show
# compute absolute SMD
smd_matchit.cps_plus <- compute_abs_smd_matchit(methods.cps_plus)
smd_matchit.psid_plus <- compute_abs_smd_matchit(methods.psid_plus)
```

#### Effective Sample Sizes 
```{r}
#| code-fold: show
# compute ESS
ess_matchit.cps_plus <- compute_ess_matchit(bal.cps_plus)
ess_matchit.psid_plus <- compute_ess_matchit(bal.psid_plus)
```

#### Visuals
```{r, class.source = "fold-show", fig.cap='FIGURE3.'}
#| code-fold: show
# visualize covariate balance 
plot_matchit(methods.cps_plus, "NSW-CPS1-PLUS")
plot_matchit(methods.psid_plus, "NSW-PSID1-PLUS")
```

### Weighting
```{r}
#| code-fold: show
# list all weights
weight.cps_plus <- list(
  ipw = nsw_cps_plus$ipw_weight,
  smr_tr = nsw_cps_plus$smr_weight,
  mw = nsw_cps_plus$opt_weight,
  ow = nsw_cps_plus$overlap_weight,
  ew = nsw_cps_plus$ebal_weight
)

weight.psid_plus <- list(
  ipw = nsw_psid_plus$ipw_weight,
  smr_tr = nsw_psid_plus$smr_weight,
  mw = nsw_psid_plus$opt_weight,
  ow = nsw_psid_plus$overlap_weight,
  ew = nsw_psid_plus$ebal_weight
)
```

#### SMD
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# compute absolute SMD 
smd_weight.cps_plus <- compute_abs_smd_weight(nsw_cps_plus, "treat", covar, weight_columns)
smd_weight.psid_plus <- compute_abs_smd_weight(nsw_psid_plus, "treat", covar, weight_columns)
```

#### ESS
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# compute ESS
ess_weight.cps_plus <- compute_ess_weight(nsw_cps_plus, "treat", covar, weight_columns)
ess_weight.psid_plus <- compute_ess_weight(nsw_psid_plus, "treat", covar, weight_columns)
```

#### Visuals
```{r, class.source = "fold-show", fig.cap='FIGURE4.'}
#| code-fold: show
# visualize covariate balance
plot_weighting_methods(nsw_cps_plus, "treat", covar, weight.cps_plus, "NSWW-CPS1-PLUS") 
plot_weighting_methods(nsw_psid_plus, "treat", covar, weight.psid_plus, "NSW-PSID1-PLUS")
```

### Truncation
Methods
```{r}
#| code-fold: show
# list truncation methods
trunc.cps_plus <- list(
  fix_max_value_trunc.cps_plus = nsw_cps_plus.fixed,
  at_perc_trunc.cps_plus = nsw_cps_plus.percent,
  adap_weight_trunc.cps_plus = nsw_cps_plus.adapt
)

trunc.psid_plus <- list(
  fix_max_value_trunc.psid_plus = nsw_psid_plus.fixed,
  at_perc_trunc.psid_plus = nsw_psid_plus.percent,
  adap_weight_trunc.psid_plus = nsw_psid_plus.adapt
)
```

#### SMD
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# compute absolute SMD
smd_trunc.cps_plus <- compute_abs_smd_trunc(trunc.cps_plus, "treat", covar, weight_columns)
smd_trunc.psid_plus <- compute_abs_smd_trunc(trunc.psid_plus, "treat", covar, weight_columns)
```

#### ESS
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# compute ESS
ess_trunc.cps_plus <- compute_ess_trunc(trunc.cps_plus, "treat", covar, weight_columns)
ess_trunc.psid_plus <- compute_ess_trunc(trunc.psid_plus, "treat", covar, weight_columns)
```

#### Visuals
```{r, class.source = "fold-show", fig.cap='FIGURE5.'}
#| code-fold: show
# visualize covariate balance
plot_trunc_methods(trunc.cps_plus, "treat", covar, weight_columns, "NSW-CPS1-PLUS")
plot_trunc_methods(trunc.psid_plus, "treat", covar, weight_columns, "NSW-PSID1-PLUS")
```

### Trimming
Methods
```{r}
#| code-fold: show
# list trimming objects
trim.cps_plus <- list(
  original = nsw_cps_plus,  
  ps_threshold = nsw_cps.trim_match,  
  common_range = nsw_cps_plus.common,      
  crump = nsw_cps_plus.crump,      
  stuermer = nsw_cps_plus.stuermer,     
  walker = nsw_cps_plus.walker    
)

trim.psid_plus <- list(
  original = nsw_psid_plus,
  ps_threshold = nsw_psid.trim_match,
  common_range = nsw_psid_plus.common,
  crump = nsw_psid_plus.crump,
  stuermer = nsw_psid_plus.stuermer,
  walker = nsw_psid_plus.walker
)
```

#### SMD
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# compute absolute SMD
smd_trim.cps_plus <- compute_abs_smd_trim(trim.cps_plus, "treat", covar)
smd_trim.psid_plus <- compute_abs_smd_trim(trim.psid_plus, "treat", covar)
```

#### ESS
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# compute ESS
ess_trim.cps_plus <- compute_ess_trim(trim.cps_plus, "treat", covar)
ess_trim.psid_plus <- compute_ess_trim(trim.psid_plus, "treat", covar)
```

#### Visuals
```{r, class.source = "fold-show", fig.cap='FIGURE6.'}
#| code-fold: show
# visualize overlap
plot_trim(trim.cps_plus, treat, covar)
plot_trim(trim.psid_plus, treat, covar)
```

```{r, class.source = "fold-show", fig.cap='FIGURE7.'}
#| code-fold: show
# visualize covariate balance
love.plot(nsw_cps, nsw_cps.trim_match, treat, covar = covar, title = "NSW-CPS1-PLUS - propensity threshold trimming")
love.plot(nsw_cps_plus, nsw_cps_plus.common, treat, covar, title = "NSW-CPS1-PLUS - common range trimming")
love.plot(nsw_cps_plus, nsw_cps_plus.crump,  treat, covar, title = "NSW-CPS1-PLUS - crump trimming") 
love.plot(nsw_cps_plus, nsw_cps_plus.stuermer, treat, covar, title = "NSW-CPS1-PLUS - stuermer trimming")
love.plot(nsw_cps_plus, nsw_cps_plus.walker,  treat, covar, title = "NSW-CPS1-PLUS - walker trimming")

love.plot(nsw_psid, nsw_psid.trim_match, treat, covar = covar, title = "NSW-PSID1-PLUS - propensity threshold trimming")
love.plot(nsw_psid_plus, nsw_psid_plus.common, treat, covar, title = "NSW-PSID1-PLUS - common range trimming")
love.plot(nsw_psid_plus, nsw_psid_plus.crump, treat, covar, title = "NSW-PSID1-PLUS - crump trimming")
love.plot(nsw_psid_plus, nsw_psid_plus.stuermer, treat, covar, title = "NSW-PSID1-PLUS - stuermer trimming")
love.plot(nsw_psid_plus, nsw_psid_plus.walker,  treat, covar, title = "NSW-PSID1-PLUS - walker trimming")
```

## Combined methods
```{r}
# list all combined method results
comb_meth.cps_plus <- list(
  ipw = ipw_comb.cps_plus,
  smr_treated = smr_treat_comb.cps_plus,
  overlap = ov_comb.cps_plus,
  entropy = entropy_comb.cps_plus
)

comb_meth.psid_plus <- list(
  ipw = ipw_comb.psid_plus,
  smr_treated = smr_treat_comb.psid_plus,
  overlap = ov_comb.psid_plus,
  entropy = entropy_comb.psid_plus
)
```

#### SMD
```{r}
# compute absolute SMD
smd_all_comb_meth.cps_plus <- compute_smd_all_datasets(comb_meth.cps_plus, "treat", covar)
smd_all_comb_meth.psid_plus <- compute_smd_all_datasets(comb_meth.psid_plus, "treat", covar)
```

#### ESS
```{r}
# compute ESS
ess_all_comb_meth.cps_plus <- compute_ess_all_datasets(comb_meth.cps_plus, "treat", covar)
ess_all_comb_meth.psid_plus <- compute_ess_all_datasets(comb_meth.psid_plus, "treat", covar)
```

#### Visuals
```{r, message=FALSE, warning=FALSE, class.source = "fold-show", fig.cap='FIGURE8.'}
# visualize overlap
plot_comb_overlap(comb_meth.cps_plus, comb_meth.psid_plus, "treat", covar, prefix_cps = "NSW-CPS1", prefix_psid = "NSW-PSID1")
```

```{r, message=FALSE, warning=FALSE, class.source = "fold-show", fig.cap='FIGURE9.'} 
# visualize covariate balance
plot_comb_love_plots(comb_meth.cps_plus, comb_meth.psid_plus, "treat", covar, prefix_cps = "NSW-CPS1", prefix_psid = "NSW-PSID1")
```

ADD EXPLANATION HERE

### Getting top methods and datasets
```{r, message=FALSE, warning=FALSE}
# combine all results
all_cps_plus <- combine_results("cps_plus")
all_psid_plus <- combine_results("psid_plus") 

# print all results
print(all_cps_plus)
print(all_psid_plus)
```

```{r, message=FALSE, warning=FALSE}
# save results 
save_csv(all_cps_plus, "CPS1_PLUS_all_results_nsw")
save_csv(all_psid_plus, "PSID1_PLUS_all_results_nsw")
```

```{r}
ranked_cps_plus  <- assess_methods(all_cps_plus)
ranked_psid_plus <- assess_methods(all_psid_plus)
```

```{r}
# get top 5 methods for each dataset
top5_methods.cps_plus <- get_top_methods(ranked_cps_plus, top_n = 5)
top5_methods.psid_plus <- get_top_methods(ranked_psid_plus, top_n = 5)

# save results 
save_csv(top5_methods.cps_plus, "CPS1_PLUS_top5_methods_nsw")
save_csv(top5_methods.psid_plus, "PSID1_PLUS_top5_methods_nsw")
```

The table shows that CPS1 and PSID1 share the same top five methods, with the exception of one differing method and a variation in their ordering for PSID1.
```{r}
dataset_list_cps <- list(
  "All" = nsw_cps_plus,
  "original" = nsw_cps_plus,
  "nn" = m.out.cps_plus.nearest, 
  "caliper" = m.out.cps_plus.caliper,
  "card" = m.out.cps_plus.card,
  "cem" = m.out.cps_plus.cem,
  "cS" = m.out.cps_plus.cs,
  "k2"  = m.out.cps_plus.k2,
  "k3" = m.out.cps_plus.k3,
  "mahvars" = m.out.cps_plus.mahvars,
  "optimal_full" = m.out.cps_plus.optimal_full,
  "optimal_pair" = m.out.cps_plus.optimal_pair,
  "gen_full" = m.out.cps_plus.general_full,
  "genetic" = m.out.cps_plus.genetic,
  "exact" = m.out.cps_plus.exact,
  "subcl" = m.out.cps_plus.subcl,
  "profile"  = m.out.cps_plus.profile,
  "ipw_weight" = nsw_cps_plus$ipw_weight, 
  "smr_weight" = nsw_cps_plus$smr_weight,
  "opt_weight" = nsw_cps_plus$opt_weight,
  "overlap_weight" = nsw_cps_plus$overlap_weight,
  "ebal_weight" = nsw_cps_plus$ebal_weight,
  "fix_max_value_trunc_ebal_weight" = nsw_cps_plus.fixed,
  "fix_max_value_trunc_ipw_weight" = nsw_cps_plus.fixed,
  "fix_max_value_trunc_opt_weight" = nsw_cps_plus.fixed,
  "fix_max_value_trunc_overlap_weight" = nsw_cps_plus.fixed,
  "fix_max_value_trunc_smr_weight" = nsw_cps_plus.fixed,
  "at_perc_trunc_ebal_weight" = nsw_cps_plus.percent,
  "at_perc_trunc_ipw_weight"  = nsw_cps_plus.percent,
  "at_perc_trunc_opt_weight"  = nsw_cps_plus.percent,
  "at_perc_trunc_overlap_weight" = nsw_cps_plus.percent,
  "at_perc_trunc_smr_weight" = nsw_cps_plus.percent,
  "adap_weight_trunc_ebal_weight" = nsw_cps_plus.adapt,
  "adap_weight_trunc_ipw_weight" = nsw_cps_plus.adapt,
  "adap_weight_trunc_opt_weight" = nsw_cps_plus.adapt,
  "adap_weight_trunc_overlap_weight" = nsw_cps_plus.adapt,
  "adap_weight_trunc_smr_weight" = nsw_cps_plus.adapt,
  "ps_threshold" = nsw_cps.trim_match,
  "common_range" = nsw_cps_plus.common,
  "stuermer" = nsw_cps_plus.stuermer,
  "walker" = nsw_cps_plus.walker,
  "crump" = nsw_cps_plus.crump,
  "ipw_common_range" = ipw_comb.cps_plus[[1]],
  "ipw_crump" = ipw_comb.cps_plus[[2]],
  "ipw_ps_threshold" = ipw_comb.cps_plus[[3]],
  "ipw_stuermer" = ipw_comb.cps_plus[[4]],
  "ipw_walker" = ipw_comb.cps_plus[[5]],
  "smr_treated_common_range" = smr_treat_comb.cps_plus[[1]],
  "smr_treated_crump" = smr_treat_comb.cps_plus[[2]],
  "smr_treated_ps_threshold" = smr_treat_comb.cps_plus[[3]],
  "smr_treated_stuermer" = smr_treat_comb.cps_plus[[4]],
  "smr_treated_walker" = smr_treat_comb.cps_plus[[5]],
  "overlap_common_range" = ov_comb.cps_plus[[1]],
  "overlap_crump" = ov_comb.cps_plus[[2]],
  "overlap_ps_threshold" = ov_comb.cps_plus[[3]],
  "overlap_stuermer" = ov_comb.cps_plus[[4]],
  "overlap_walker" = ov_comb.cps_plus[[5]],
  "entropy_common_range" = entropy_comb.cps_plus[[1]],
  "entropy_crump" = entropy_comb.cps_plus[[2]],
  "entropy_ps_threshold" = entropy_comb.cps_plus[[3]],
  "entropy_stuermer" = entropy_comb.cps_plus[[4]],
  "entropy_walker" = entropy_comb.cps_plus[[5]])
```

```{r}
dataset_list_psid <- list(
  "All" = nsw_psid_plus, 
  "original" = nsw_psid_plus, 
  "nn" = m.out.psid_plus.nearest, 
  "caliper"= m.out.psid_plus.caliper,
  "card" = m.out.psid_plus.card,
  "cem" = m.out.psid_plus.cem,
  "cS" = m.out.psid_plus.cs,
  "k2" = m.out.psid_plus.k2,
  "k3" = m.out.psid_plus.k3,
  "mahvars" = m.out.psid_plus.mahvars,
  "optimal_full" = m.out.psid_plus.optimal_full,
  "optimal_pair" = m.out.psid_plus.optimal_pair,
  "gen_full" = m.out.psid_plus.general_full,
  "genetic" = m.out.psid_plus.genetic,
  "exact" = m.out.psid_plus.exact,
  "subcl" = m.out.psid_plus.subcl,
  "profile" = m.out.psid_plus.profile,
  "ipw_weight" = nsw_psid_plus$ipw_weight, 
  "smr_weight" = nsw_psid_plus$smr_weight,
  "opt_weight" = nsw_psid_plus$opt_weight,
  "overlap_weight" = nsw_psid_plus$overlap_weight,
  "ebal_weight" = nsw_psid_plus$ebal_weight,
  "fix_max_value_trunc_ebal_weight" = nsw_psid_plus.fixed,
  "fix_max_value_trunc_ipw_weight" = nsw_psid_plus.fixed,
  "fix_max_value_trunc_opt_weight" = nsw_psid_plus.fixed,
  "fix_max_value_trunc_overlap_weight" = nsw_psid_plus.fixed,
  "fix_max_value_trunc_smr_weight" = nsw_psid_plus.fixed,
  "at_perc_trunc_ebal_weight" = nsw_psid_plus.percent,
  "at_perc_trunc_ipw_weight" = nsw_psid_plus.percent,
  "at_perc_trunc_opt_weight" = nsw_psid_plus.percent,
  "at_perc_trunc_overlap_weight" = nsw_psid_plus.percent,
  "at_perc_trunc_smr_weight" = nsw_psid_plus.percent,
  "adap_weight_trunc_ebal_weight" = nsw_psid_plus.adapt,
  "adap_weight_trunc_ipw_weight" = nsw_psid_plus.adapt,
  "adap_weight_trunc_opt_weight" = nsw_psid_plus.adapt,
  "adap_weight_trunc_overlap_weight" = nsw_psid_plus.adapt,
  "adap_weight_trunc_smr_weight" = nsw_psid_plus.adapt,
  "ps_threshold" = nsw_psid.trim_match,
  "common_range" = nsw_psid_plus.common,
  "stuermer" = nsw_psid_plus.stuermer,
  "walker" = nsw_psid_plus.walker,
  "crump" = nsw_psid_plus.crump,
  "ipw_common_range" = ipw_comb.psid_plus[[1]],
  "ipw_crump"= ipw_comb.psid_plus[[2]],
  "ipw_ps_threshold"= ipw_comb.psid_plus[[3]],
  "ipw_stuermer"= ipw_comb.psid_plus[[4]],
  "ipw_walker" = ipw_comb.psid_plus[[5]],
  "smr_treated_common_range" = smr_treat_comb.psid_plus[[1]],
  "smr_treated_crump"= smr_treat_comb.psid_plus[[2]],
  "smr_treated_ps_threshold" = smr_treat_comb.psid_plus[[3]],
  "smr_treated_stuermer" = smr_treat_comb.psid_plus[[4]],
  "smr_treated_walker" = smr_treat_comb.psid_plus[[5]],
  "overlap_common_range" = ov_comb.psid_plus[[1]],
  "overlap_crump" = ov_comb.psid_plus[[2]],
  "overlap_ps_threshold"  = ov_comb.psid_plus[[3]],
  "overlap_stuermer" = ov_comb.psid_plus[[4]],
  "overlap_walker"= ov_comb.psid_plus[[5]],
  "entropy_common_range" = entropy_comb.psid_plus[[1]],
  "entropy_crump" = entropy_comb.psid_plus[[2]],
  "entropy_ps_threshold" = entropy_comb.psid_plus[[3]],
  "entropy_stuermer" = entropy_comb.psid_plus[[4]],
  "entropy_walker" = entropy_comb.psid_plus[[5]])
```

```{r}
# create datasets corresponding to the top 5 methods for each dataset
top5_datasets.cps_plus <- create_top5_datasets(dataset_list_cps, top5_methods.cps_plus)
top5_datasets.psid_plus <- create_top5_datasets(dataset_list_psid, top5_methods.psid_plus)
```

```{r}
# save datasets into .RData files
save_top5_individual_files(dataset_list_cps, top5_methods.cps_plus, prefix = "nsw_cps")
save_top5_individual_files(dataset_list_psid, top5_methods.psid_plus, prefix = "nsw_psid")
```

## Estimating
### ATT
```{r, message=FALSE, warning=FALSE}
out1 <- estimate_all(nsw, "re78", "treat", covar)
out2 <- estimate_all(nsw_cps, "re78", "treat", covar)
out3 <- estimate_all(nsw_psid, "re78", "treat", covar)
```

```{r, message=FALSE, warning=FALSE}
out4 <- estimate_all(nsw_cps.trim_match, "re78", "treat", covar) 
out5 <- estimate_all(nsw_psid.trim_match, "re78", "treat", covar)
```

```{r, message=FALSE, warning=FALSE}
out.cps_plus <- lapply(top5_datasets.cps_plus, function(d) estimate_all(d, "re78", "treat", covar))
out.psid_plus <- lapply(top5_datasets.psid_plus, function(d) estimate_all(d, "re78", "treat", covar))

out6 <- out.cps_plus[[1]]
out7 <- out.cps_plus[[2]]
out8 <- out.cps_plus[[3]]
out9 <- out.cps_plus[[4]]
out10 <- out.cps_plus[[5]]

out11 <- out.psid_plus[[1]]
out12 <- out.psid_plus[[2]]
out13 <- out.psid_plus[[3]]
out14 <- out.psid_plus[[4]]
out15 <- out.psid_plus[[5]]
```

```{r}
# build plot titles 
base_titles <- c("(A) NSW-Experimental", "(B) NSW-CPS1" , "(C) NSW-PSID1", "(D) Trimmed NSW-CPS1 ", "(E) Trimmed NSW-PSID1")
top_start <- 6 # F is 6th letter
num_cps <- length(top5_methods.cps_plus)
num_psid <- length(top5_methods.psid_plus)
top_letters_cps <- LETTERS[top_start:(top_start + num_cps - 1)]
top_letters_psid <- LETTERS[(top_start + num_cps):(top_start + num_cps + num_psid - 1)]
top5_titles.cps_plus <- paste0("(", top_letters_cps, ") Top CPS1: ", top5_methods.cps_plus)
top5_titles.psid_plus <- paste0("(", top_letters_psid, ") Top PSID1: ", top5_methods.psid_plus)
plot_titles <- c(base_titles, top5_titles.cps_plus, top5_titles.psid_plus)

# combine all results
all_outs <- c(list(out1, out2, out3, out4, out5), out.cps_plus, out.psid_plus)
```

```{r, out.width='100%', fig.asp=1, fig.cap="FIGURE 10. ATT Estimates Given Unconfoundedness using NSW Samples"}
# plot results
band <- out1[1, 3:4]
est  <- out1[1, 1]
plot_att_panels(all_outs, plot_titles, band, est)
```

```{r}
# save results
save_att_panels(all_outs, plot_titles, band, est, "nsw")
```

ADD EXPLANATION HERE

```{r, warning=FALSE}

# prepare all results in the order shown in the plots
all_summaries <- lapply(all_outs, eval_att)
att_summary <- do.call(rbind, all_summaries)
rownames(att_summary) <- plot_titles
att_summary
```

The ATT results are presented in the table below:
```{r class.source = 'fold-hide'}
#| code-fold: show
# get result matrix
result_mat <- create_matrix_results(all_outs, plot_titles)
knitr::kable(result_mat, booktabs = TRUE, caption = "NSW ATT Estimates and SEs for All Samples and Estimators")
```

ADD EXPLANATION HERE

```{r}
# save results 
save_csv(result_mat, "NSW_att_estimates")
```

## Alternative Estimands
### Conditional Average Treatment Effect on the Treated (CATT)
```{r, warning=FALSE}
#| code-fold: show
catt.nsw <- catt(nsw, Y, treat, covar)
catt.cps <- catt(nsw_cps, Y, treat, covar)
catt.psid <- catt(nsw_psid, Y, treat, covar)
catt.cps.trim <- catt(nsw_cps.trim_match, Y, treat, covar)
catt.psid.trim <- catt(nsw_psid.trim_match, Y, treat, covar)
```

```{r, warning=FALSE}
#| code-fold: show
catt.top5_cps_plus <- lapply(top5_datasets.cps_plus, function(d) catt(d, Y, treat, covar))
catt.top5_psid_plus <- lapply(top5_datasets.psid_plus, function(d) catt(d, Y, treat, covar))
```

```{r, out.width='100%', fig.asp=1, fig.cap="FIGURE 11. CATT Estimates using NSW Data"}
#| code-fold: show
# combine all catt objects 
all_catt <- c(list(catt.nsw, catt.cps, catt.psid, catt.cps.trim, catt.psid.trim), catt.top5_cps_plus, catt.top5_psid_plus)

# plot results
plot_catt_panels(all_catt, plot_titles)
```

```{r}
# save results
save_catt_panels(all_catt, plot_titles, prefix = "nsw")
```

ADD EXPLANATION HERE

```{r, warning=FALSE}
#| code-fold: show
eval_catt(all_catt, plot_titles)
```

ADD EXPLANATION HERE

### Quantile Treatment Effect on the Treated (QTET)
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
qte.nsw <- est_qte(Y, treat, covar, data = nsw, cores = 4)
```

```{r, message=FALSE, warning=FALSE}
#| code-fold: show
qte.nsw_cps <- est_qte(Y, treat, covar, data = nsw_cps)
qte.nsw_psid <- est_qte(Y, treat, covar, data = nsw_psid)
qte.nsw_cps.trim <- est_qte(Y, treat, covar, data = nsw_cps.trim_match)
qte.nsw_psid.trim <- est_qte(Y, treat, covar, data = nsw_psid.trim_match) 
```

```{r, warning=FALSE}
#| code-fold: show
qte.top5_cps_plus  <- lapply(top5_datasets.cps_plus,  function(d) est_qte(Y, treat, covar, data = d))
qte.top5_psid_plus <- lapply(top5_datasets.psid_plus, function(d) est_qte(Y, treat, covar, data = d))
```

```{r, warning=FALSE}
#| code-fold: show
qte.nsw0 <- est_qte(Y, treat, NULL, data = nsw)
qte.nsw.cps0 <- est_qte(Y, treat, NULL, data = nsw_cps)
qte.nsw.psid0 <- est_qte(Y, treat, NULL, data = nsw_psid)
qte.nsw_cps.trim0 <- est_qte(Y, treat, NULL, data = nsw_cps.trim_match)
qte.nsw_psid.trim0 <- est_qte(Y, treat, NULL, data = nsw_psid.trim_match)
qte.top5_cps_plus0  <- lapply(top5_datasets.cps_plus,  function(d) est_qte(Y, treat, NULL, data = d))
qte.top5_psid_plus0 <- lapply(top5_datasets.psid_plus, function(d) est_qte(Y, treat, NULL, data = d))
```

```{r, out.width='100%', fig.asp=1, fig.cap="FIGURE 12. QTET Estimates using NSW Data: Experimental vs. Nonexperimental"}
#| code-fold: show
# combine all qte objects in order 
all_qtet <- c(list(qte.nsw, qte.nsw_cps, qte.nsw_psid, qte.nsw_cps.trim, qte.nsw_psid.trim), qte.top5.cps, qte.top5.psid)

# plot results
plot_qtet_panels(all_qtet, plot_titles, experimental_qte = qte.nsw, plots_per_page = 4, ylim = c(-25000, 15000))

# save results
save_qtet_panels(all_qtet, plot_titles, qte.nsw, plots_per_page = 4, ylim = c(-25000, 15000), prefix = "model_b_qtet")
```

ADD EXPLANATION HERE

## Sensitivity Analyses
```{r, warning=FALSE}
#| code-fold: show
# define variables
Y <- "re78"
treat <- "treat"
covar <- c("age", "education", "black", "hispanic", "married", "nodegree", "re75", "u75")
bm <- c("re75")
```

```{r, warning=FALSE}
#| code-fold: show
# check for valid datasets 
datasets_sens <- c(list(nsw, nsw_cps, nsw_psid), top5_datasets.cps_plus, top5_datasets.psid_plus)
filtered_datasets_sens <- check_filter_datasets(datasets_sens, Y, treat, covar, bm)
```

```{r, out.width='100%', fig.asp=1, fig.cap="FIGURE 14. Sensitivity Analyses NSW"}
#| code-fold: show
# loop over valid datasets and assign index
for (i in seq_along(filtered_datasets_sens)) {
    idx <- which(sapply(datasets_sens, identical, filtered_datasets_sens[[i]]))
    sens_ana(filtered_datasets_sens[[i]], Y, treat, covar, bm, kd = 1:3)
    title(main = plot_titles[idx])
}
```

```{r}
# save results
save_sensitivity_plots(filtered_datasets_sens, Y, treat, covar, bm, plot_titles, "nsw")
```

ADD EXPLANATION HERE

# Summary

---
title: "Replication and Extension of Imbens & Xu (2024) Tutorial - LaLonde-Dehejia-Wahba (LDW) Data" 
output: html_document
date: "2025-05-08"
---

# LaLonde-Dehejia-Wahba (LDW) Data
LaLonde (1986) assessed the impact of the National Supported Work Demonstration (NSW) program on both female and male participants, with females drawn from the Aid to Families with Dependent Children (AFDC) program and males from three other target groups: ex-drug addicts, ex-criminal offenders, and high-school dropouts. LaLonde used two primary data sources:

-   CPS-SSA-1, from Westat’s Matched Current Population Survey–Social Security Administration File for individuals under 55 matching specific criteria.
-   PSID-1, from the Panel Study of Income Dynamics for household heads under 55 from specific years who were not retired in 1975, adjusted for factors like employment status and poverty level, resulting in four additional comparison groups.

Dehejia and Wahba (1999) subsampled 62% of LaLonde’s original dataset focusing on 1974 earnings and unemployment status of male participants. Since the construction relies solely on pretreatment information like month of assignment and employment history to ensure treatment assignment remains orthogonal to all pretreatment variables, Dehejia and Wahba argue the refined dataset, LaLonde-Dehejia-Wahba (LDW) data, is a valid experimental sample.

Built upon LDW data, our analysis examines three samples: (1) LDW-Experimental, with 185 treated and 280 control participants from the experimental data; (2) LDW-CPS1, featuring the same treated individuals alongside 15,992 controls from CPS-SSA-1; and (3) LDW-PSID1, including the same treated participants and 2,490 controls from PSID-1. Then, we apply the same set of statistical tools to analyze the original male sample from LaLonde (1986) in section 4 as an additional demonstration.

# Set up
## Source functions and load data
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
# source functions
source("https://github.com/xuyiqing/lalonde/blob/main/tutorial/functions.R?raw=TRUE")
source("/Users/laurakreisel/Workspace/uni/semester04/thesis/lalonde/code/replication/tutorial/functions.R")
```

```{r}
# load data
load("/Users/laurakreisel/Workspace/uni/semester04/thesis/lalonde/code/replication/data/lalonde.RData")
```

## Inspect data
```{r}
#| code-fold: show
# collect datasets in a list
data <- list(
  lalonde = lalonde,
  ldw_tr   = ldw_tr,
  ldw_co   = ldw_co,
  ldw_cps  = ldw_cps,
  ldw_psid = ldw_psid
)

summary_stats <- inspect_data(data)
print(summary_stats)

# peek at the first 5 rows
lapply(data, head, 5)
```

## Load and preprocess data (LaLonde-Dehejia-Wahba (LDW))
```{r}
#| code-fold: show
# merge experimental data with CPS1 data
ldw_cps.plus <- rbind.data.frame(
  ldw_co,    # Experimental controls (260 obs)
  ldw_cps    # CPS data (16177 obs)
)

# merge experimental data with PSID1 data
ldw_psid.plus <- rbind.data.frame(
  ldw_co,    # Experimental controls (260 obs, treat=0)
  ldw_psid   # PSID data (2675 obs)
)

datasets <- list(
  ldw_cps.plus  = ldw_cps.plus,
  ldw_psid.plus = ldw_psid.plus
)

# inspect new datasets 
summary_stats_plus <- inspect_data(datasets)
print(summary_stats_plus)

# peek at first 5 rows
lapply(datasets, head, 5)
```

# Model A
```{r}
#| code-fold: show
# define variables
Y <- "re78" 
treat <- "treat" 
covar <- c("age", "education", "black", "hispanic", "married", 
           "nodegree", "re74", "re75", "u74", "u75") #re74 included
```

## Assessing overlap 

To identify the average causal effect under unconfoundedness (that ensures that the treatment assignment is independent of the potential outcomes), we need to ensure that we can estimate the average effect at every value for the covariates. Thus, we require overlaps between the treated and control units - meaning that for every combination of covariates, there are both treated and control units in the dataset. We use the `assess_overlap()` function to assess the overlaps in the propensity scores and use histograms to visualize results.

In a properly balanced experimental design, the distributions of the treatment group (red) and the control group (gray) are expected to show considerable overlap.
```{r, class.source = "fold-show", fig.cap='FIGURE1. SubfigureB:LDW-CPS1. SubfigureB:LDW-CPS1. SubfigureC:LDW-PSID1.',out.width='100%', fig.asp=0.5}
#| code-fold: show
# assess overlap
ldw_ps <- assess_overlap(data = ldw, treat = treat, cov = covar)
ldw_cps_ps <- assess_overlap(data = ldw_cps, treat = treat, cov = covar) 
ldw_psid_ps <- assess_overlap(data = ldw_psid, treat = treat, cov = covar) 
```

As anticipated, the LDW-Experimental data exhibit an almost perfect overlap. In contrast, the observational datasets display weak overlap. In particular, many treated units have propensity scores outside the range of the controls, while a large share of control units are concentrated at very low log-odds.

Next, we examine the overlap of the expanded datasets used in the subsequent analysis. The LDW-Experimental data is excluded from these steps, since randomization already guarantees covariate balance and sufficient overlap. Therefore, the methods are applied only to the ldw_cps.plus and ldw_psid.plus datasets.
```{r, class.source = "fold-show", fig.cap='FIGURE1. SubfigureD:LDW-CPS1-Plus.SubfigureD:LDW-PSID1-Plus.', out.width='80%', fig.asp=1, fig.align='center'}
#| code-fold: show
# assess overlap
ldw_cps.plus_ps <- assess_overlap(data = ldw_cps.plus, treat = treat, cov = covar) 
ldw_psid.plus_ps <- assess_overlap(data = ldw_psid.plus, treat = treat, cov = covar) 
```

Next we set up a model formula that is used in the following analysis.
```{r}
#| code-fold: show
model <- as.formula(paste(treat, "~", paste(covar, collapse = " + ")))
```

## Improving overlap
### Matching 
#### Distance Matching
##### 1:1 Nearest neighbor matching
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
m.out.cps.nearest <- matchit(model, data = ldw_cps.plus, method = "nearest", distance = "logit", replace = TRUE)
m.out.psid.nearest <- matchit(model, data = ldw_psid.plus, method = "nearest", distance = "logit", replace = TRUE)
```

##### k:1 matching (k=2)
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
k<-2
m.out.cps.k2 <- matchit(model, data = ldw_cps.plus, method = "nearest", distance = "logit", ratio = k, replace = TRUE)
m.out.psid.k2 <- matchit(model, data = ldw_psid.plus, method = "nearest", distance = "logit", ratio = k, replace = TRUE)
```

##### k:1 matching (k=3)
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
k<-3
m.out.cps.k3 <- matchit(model, data = ldw_cps.plus, method = "nearest", distance = "logit", ratio = k, replace = TRUE)
m.out.psid.k3 <- matchit(model, data = ldw_psid.plus, method = "nearest", distance = "logit", ratio = k, replace = TRUE)
```

##### Caliper matching
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
m.out.cps.caliper <- matchit(model, data = ldw_cps.plus, method = "nearest", distance = "logit", caliper = 0.1, replace = TRUE)
m.out.psid.caliper <- matchit(model, data = ldw_psid.plus, method = "nearest", distance = "logit", caliper = 0.1, replace = TRUE)
```

##### Common support restriction matching
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
m.out.cps.cs <- matchit(model, data = ldw_cps.plus, method = "nearest", distance = "logit", discard = "both", replace = TRUE)
m.out.psid.cs <- matchit(model, data = ldw_psid.plus, method = "nearest", distance = "logit", discard = "both", replace = TRUE)
```

##### Mahalanobis distance matching (mahvars) 
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
m.out.cps.mahvars <- matchit(model, data = ldw_cps.plus, method = "nearest", distance = "logit", caliper = 0.2, mahvars = ~ age + education + re74 + re75, replace = FALSE)
m.out.psid.mahvars <- matchit(model, data = ldw_psid.plus, method = "nearest", distance = "logit", caliper = 0.2, mahvars = ~ age + education + re74 + re75, replace = FALSE)
```

##### Optimal pair matching
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
m.out.cps.optimal_pair <- matchit(model, data = ldw_cps.plus, method = "optimal", distance = "logit")
m.out.psid.optimal_pair <- matchit(model, data = ldw_psid.plus, method = "optimal", distance = "logit")
```

##### Optimal full matching
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
m.out.cps.optimal_full <- matchit(model, data = ldw_cps.plus, method = "full", distance = "logit")
m.out.psid.optimal_full <- matchit(model, data = ldw_psid.plus, method = "full", distance = "logit")
```

##### Generalized full matching
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
m.out.cps.general_full <- matchit(model, data = ldw_cps.plus, method = "quick", distance = "logit")
m.out.psid.general_full <- matchit(model, data = ldw_psid.plus, method = "quick", distance = "logit")
```

##### Genetic matching
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
m.out.cps.genetic <- matchit(model, data = ldw_cps.plus, method = "genetic", distance = "logit", replace = TRUE, pop.size = 100)
m.out.psid.genetic <- matchit(model, data = ldw_psid.plus, method = "genetic", distance = "logit", replace = TRUE, pop.size = 100)
```

#### Stratum matching
##### Exact matching (exact)
Strata = unique covariate profiles (raw covariates)
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
m.out.cps.exact <- matchit(model, data = ldw_cps.plus, method = "exact")
m.out.psid.exact <- matchit(model, data = ldw_psid.plus, method = "exact")
```

##### Coarsened matching (cem)
Strata = coarsened versions of covariates
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
m.out.cps.cem <- matchit(model, data = ldw_cps.plus, method = "cem")
m.out.psid.cem <- matchit(model, data = ldw_psid.plus, method = "cem")
```

##### Subclassification 
Strata = bins of the propensity score
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
m.out.cps.subcl <- matchit(model, data = ldw_cps.plus, method = "subclass", subclass = 5)
m.out.psid.subcl <- matchit(model, data = ldw_psid.plus, method = "subclass", subclass = 5)
```

#### Pure subset selection
##### Cardinality profile matching
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
m.out.cps.card <- matchit(model, data = ldw_cps.plus, method = "cardinality", tols = 0.1, ratio = 1)
m.out.psid.card <- matchit(model, data = ldw_psid.plus, method = "cardinality", tols = 0.1, ratio = 1)
```

##### Profile matching
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
m.out.cps.profile <- matchit_profile(ldw_cps.plus, treat, covar)
m.out.psid.profile <- matchit_profile(ldw_psid.plus, treat, covar)
```

### Weighting
#### Inverse probability weights (IPW)
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
w.out.cps.ipw <- weightit(model, data = ldw_cps.plus, method = "ps", estimand = "ATT")
w.out.psid.ipw <- weightit(model, data = ldw_psid.plus, method = "ps", estimand = "ATT")

ldw_cps.plus$ipw_weight <- w.out.cps.ipw$weights
ldw_psid.plus$ipw_weight <- w.out.psid.ipw$weights
```

#### Standardized mortality ratio (SMR) treated weights
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
ldw_cps.plus$smr_weight <- create_smr_weights(ldw_cps.plus, model, "ATT")
ldw_psid.plus$smr_weight <- create_smr_weights(ldw_psid.plus, model, "ATT")
```

#### Standardized mortality ratio (SMR) untreated weights
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
ldw_cps.plus$smr_ate_weight <- create_smr_weights(ldw_cps.plus, model, "ATE")
ldw_psid.plus$smr_ate_weight <- create_smr_weights(ldw_psid.plus, model, "ATE")
```

#### Matching weights
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
w.out.cps.opt <- weightit(model, data = ldw_cps.plus, method = "optweight", estimand = "ATT")
w.out.psid.opt <- weightit(model, data = ldw_psid.plus, method = "optweight", estimand = "ATT")
ldw_cps.plus$opt_weight <- w.out.cps.opt$weights
ldw_psid.plus$opt_weight <- w.out.psid.opt$weights
```

#### Overlap weights
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
ldw_cps.plus$overlap_weight <- create_overlap_weights(ldw_cps.plus, model)
ldw_psid.plus$overlap_weight <- create_overlap_weights(ldw_psid.plus, model)
```

#### Entropy weights
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
w.out.cps.ebal <- weightit(model, data = ldw_cps.plus, method = "ebal", estimand = "ATT")
w.out.psid.ebal <- weightit(model, data = ldw_psid.plus, method = "ebal", estimand = "ATT")

ldw_cps.plus$ebal_weight <- w.out.cps.ebal$weights
ldw_psid.plus$ebal_weight <- w.out.psid.ebal$weights
```

### Trimming 
#### Common range trimming
```{r}
#| code-fold: show
ldw_cps_common   <- common_range_trim(ldw_cps.plus_ps)
ldw_psid_common  <- common_range_trim(ldw_psid.plus_ps)
```

#### Propensity score trimming (Crump)
```{r}
#| code-fold: show
ldw_cps_crump    <- crump_trim(ldw_cps.plus_ps, lower = 0.1, upper = 0.9)
ldw_psid_crump   <- crump_trim(ldw_psid.plus_ps, lower = 0.1, upper = 0.9)
```

#### Stürmer trimming
```{r}
#| code-fold: show
ldw_cps_stuermer  <- stuermer_trim(ldw_cps.plus_ps)
ldw_psid_stuermer <- stuermer_trim(ldw_psid.plus_ps)
```

#### Walker trimming
```{r}
#| code-fold: show
ldw_cps_walker   <- walker_trim(ldw_cps.plus_ps)
ldw_psid_walker  <- walker_trim(ldw_psid.plus_ps)
```

### Truncation
```{r}
#| code-fold: show
# List of weight columns to apply truncation for
weight_columns <- c("ipw_weight", "smr_weight", "smr_ate_weight", "opt_weight", "overlap_weight","ebal_weight")
```

#### Fixed maximum value truncation
```{r}
#| code-fold: show
ldw_cps_fixed <- ldw_cps.plus
for (wcol in weight_columns) {
  if (wcol %in% names(ldw_cps_fixed)) {
    ldw_cps_fixed <- truncate_weights_fixed(ldw_cps_fixed, weight_col = wcol, max_weight = 10)
  }
}

ldw_psid_fixed <- ldw_psid.plus
for (wcol in weight_columns) {
  if (wcol %in% names(ldw_psid_fixed)) {
    ldw_psid_fixed <- truncate_weights_fixed(ldw_psid_fixed, weight_col = wcol, max_weight = 10)
  }
}
```

#### At percentile truncation
```{r}
#| code-fold: show
ldw_cps_percent <- ldw_cps.plus
for (wcol in weight_columns) {
  if (wcol %in% names(ldw_cps_percent)) {
    ldw_cps_percent <- truncate_weights_percentile(ldw_cps_percent, weight_col = wcol, percentile = 0.99)
  }
}

ldw_psid_percent <- ldw_psid.plus
for (wcol in weight_columns) {
  if (wcol %in% names(ldw_psid_percent)) {
    ldw_psid_percent <- truncate_weights_percentile(ldw_psid_percent, weight_col = wcol, percentile = 0.99)
  }
}
```

#### Adaptive weight truncation

We inspect the variance of the estimated weights. If variance is zero, adaptive weight truncation is not meaningful. 
```{r}
#| code-fold: show
for (wcol in weight_columns) {
  if (wcol %in% names(ldw_cps.plus)) {
    check_weights(ldw_cps.plus, wcol)
  } else {
    cat("Column", wcol, "not found in ldw_cps.plus\n")
  }
}
```

Regarding these results we only apply this method to `ipw, smr, smr_ate` and `ebal`, where it can help mitigate the influence of extreme weights. 
```{r}
#| code-fold: show
weight_columns_at <- c("ipw_weight", "smr_weight", "smr_ate_weight", "overlap_weight", "ebal_weight")
```

```{r}
#| code-fold: show
ldw_cps_adapt <- ldw_cps.plus
for (wcol in weight_columns_at) {
  if (wcol %in% names(ldw_cps_adapt)) {
    ldw_cps_adapt <- truncate_weights_adaptive(ldw_cps_adapt, weight_col = wcol, c = 3)
  }
}

ldw_psid_adapt <- ldw_psid.plus
for (wcol in weight_columns_at) {
  if (wcol %in% names(ldw_psid_adapt)) {
    ldw_psid_adapt <- truncate_weights_adaptive(ldw_psid_adapt, weight_col = wcol, c = 3)
  }
}
```

### Combination of methods
#### IPW with 1) common range 2) Stürmer 3) Walker 4) Crump
```{r}
#| code-fold: show
ipw_comb_cps <- list(
  common_range = trim_attach_weights(ldw_cps_common, ldw_cps.plus, "ipw_weight"),
  sturmer      = trim_attach_weights(ldw_cps_stuermer, ldw_cps.plus, "ipw_weight"),
  walker       = trim_attach_weights(ldw_cps_walker, ldw_cps.plus, "ipw_weight"),
  crump        = trim_attach_weights(ldw_cps_crump, ldw_cps.plus, "ipw_weight")
)

ipw_comb_psid <- list(
  common_range = trim_attach_weights(ldw_psid_common, ldw_psid.plus, "ipw_weight"),
  sturmer      = trim_attach_weights(ldw_psid_stuermer, ldw_psid.plus, "ipw_weight"),
  walker       = trim_attach_weights(ldw_psid_walker, ldw_psid.plus, "ipw_weight"),
  crump        = trim_attach_weights(ldw_psid_crump, ldw_psid.plus, "ipw_weight")
)
```

#### SMR treated weights with 1) common range 2) Stürmer 3) Walker 4) Crump
```{r}
#| code-fold: show
smr_treat_comb_cps <- list(
  common_range = trim_attach_weights(ldw_cps_common, ldw_cps.plus, "smr_weight"),
  sturmer      = trim_attach_weights(ldw_cps_stuermer, ldw_cps.plus, "smr_weight"),
  walker       = trim_attach_weights(ldw_cps_walker, ldw_cps.plus, "smr_weight"),
  crump        = trim_attach_weights(ldw_cps_crump, ldw_cps.plus, "smr_weight")
)

smr_treat_comb_psid <- list(
  common_range = trim_attach_weights(ldw_psid_common, ldw_psid.plus, "smr_weight"),
  sturmer      = trim_attach_weights(ldw_psid_stuermer, ldw_psid.plus, "smr_weight"),
  walker       = trim_attach_weights(ldw_psid_walker, ldw_psid.plus, "smr_weight"),
  crump        = trim_attach_weights(ldw_psid_crump, ldw_psid.plus, "smr_weight")
)
```

#### SMR untreated weights with 1) common range 2) Stürmer 3) Walker 4) Crump
```{r}
#| code-fold: show
smr_untreat_comb_cps <- list(
  common_range = trim_attach_weights(ldw_cps_common, ldw_cps.plus, "smr_ate_weight"),
  sturmer      = trim_attach_weights(ldw_cps_stuermer, ldw_cps.plus, "smr_ate_weight"),
  walker       = trim_attach_weights(ldw_cps_walker, ldw_cps.plus, "smr_ate_weight"),
  crump        = trim_attach_weights(ldw_cps_crump, ldw_cps.plus, "smr_ate_weight")
)

smr_untreat_comb_psid <- list(
  common_range = trim_attach_weights(ldw_psid_common, ldw_psid.plus, "smr_ate_weight"),
  sturmer      = trim_attach_weights(ldw_psid_stuermer, ldw_psid.plus, "smr_ate_weight"),
  walker       = trim_attach_weights(ldw_psid_walker, ldw_psid.plus, "smr_ate_weight"),
  crump        = trim_attach_weights(ldw_psid_crump, ldw_psid.plus, "smr_ate_weight")
)
```

#### Overlap weights with 1) common range 2) Stürmer 3) Walker 4) Crump
```{r}
#| code-fold: show
ov_comb_cps <- list(
  common_range = trim_attach_weights(ldw_cps_common, ldw_cps.plus, "overlap_weight"),
  sturmer      = trim_attach_weights(ldw_cps_stuermer, ldw_cps.plus, "overlap_weight"),
  walker       = trim_attach_weights(ldw_cps_walker, ldw_cps.plus, "overlap_weight"),
  crump        = trim_attach_weights(ldw_cps_crump, ldw_cps.plus, "overlap_weight")
)

ov_comb_psid <- list(
  common_range = trim_attach_weights(ldw_psid_common, ldw_psid.plus, "overlap_weight"),
  sturmer      = trim_attach_weights(ldw_psid_stuermer, ldw_psid.plus, "overlap_weight"),
  walker       = trim_attach_weights(ldw_psid_walker, ldw_psid.plus, "overlap_weight"),
  crump        = trim_attach_weights(ldw_psid_crump, ldw_psid.plus, "overlap_weight")
)
```

#### Matching weights with 1) common range 2) Stürmer 3) Walker 4) Crump
```{r}
#| code-fold: show
matching_comb_cps <- list(
  common_range = trim_attach_weights(ldw_cps_common, ldw_cps.plus, "opt_weight"),
  sturmer      = trim_attach_weights(ldw_cps_stuermer, ldw_cps.plus, "opt_weight"),
  walker       = trim_attach_weights(ldw_cps_walker, ldw_cps.plus, "opt_weight"),
  crump        = trim_attach_weights(ldw_cps_crump, ldw_cps.plus, "opt_weight")
)

matching_comb_psid <- list(
  common_range = trim_attach_weights(ldw_psid_common, ldw_psid.plus, "opt_weight"),
  sturmer      = trim_attach_weights(ldw_psid_stuermer, ldw_psid.plus, "opt_weight"),
  walker       = trim_attach_weights(ldw_psid_walker, ldw_psid.plus, "opt_weight"),
  crump        = trim_attach_weights(ldw_psid_crump, ldw_psid.plus, "opt_weight")
)  
```

#### Entropy weights with 1) common range 2) Stürmer 3) Walker 4) Crump
```{r}
#| code-fold: show
entropy_comb_cps <- list(
  common_range = trim_attach_weights(ldw_cps_common, ldw_cps.plus, "ebal_weight"),
  sturmer      = trim_attach_weights(ldw_cps_stuermer, ldw_cps.plus, "ebal_weight"),
  walker       = trim_attach_weights(ldw_cps_walker, ldw_cps.plus, "ebal_weight"),
  crump        = trim_attach_weights(ldw_cps_crump, ldw_cps.plus, "ebal_weight")
)

entropy_comb_psid <- list(
  common_range = trim_attach_weights(ldw_psid_common, ldw_psid.plus, "ebal_weight"),
  sturmer      = trim_attach_weights(ldw_psid_stuermer, ldw_psid.plus, "ebal_weight"),
  walker       = trim_attach_weights(ldw_psid_walker, ldw_psid.plus, "ebal_weight"),
  crump        = trim_attach_weights(ldw_psid_crump, ldw_psid.plus, "ebal_weight")
) 
```

## Reassessing overlap
### Matching
Methods
```{r}
#| code-fold: show
# List all matching methods
methods_cps <- list(
  nn = m.out.cps.nearest,
  k2 = m.out.cps.k2,
  k3 = m.out.cps.k3,
  caliper = m.out.cps.caliper,
  cS = m.out.cps.cs,
  mahvars = m.out.cps.mahvars,
  optimal_pair = m.out.cps.optimal_pair,
  optimal_full = m.out.cps.optimal_full,
  gen_full = m.out.cps.general_full,
  genetic = m.out.cps.genetic,
  exact = m.out.cps.exact,
  cem = m.out.cps.cem,
  card = m.out.cps.card,
  profile = m.out.cps.profile,
  subcl = m.out.cps.subcl
)

methods_psid <- list(
  nn = m.out.psid.nearest,
  k2 = m.out.psid.k2,
  k3 = m.out.psid.k3,
  caliper = m.out.psid.caliper,
  cs = m.out.psid.cs,
  mahvars = m.out.psid.mahvars,
  optimal_pair = m.out.psid.optimal_pair,
  optimal_full = m.out.psid.optimal_full,
  gen_full = m.out.psid.general_full,
  genetic = m.out.psid.genetic,
  exact = m.out.psid.exact,
  cem = m.out.psid.cem,
  card = m.out.psid.card,
  profile = m.out.psid.profile,
  subcl = m.out.psid.subcl
)
```

```{r, message=FALSE, warning=FALSE}
#| code-fold: show
bal_cps <- cobalt::bal.tab(model, data = ldw_cps.plus, un = TRUE, weights = methods_cps, s.d.denom = "treated")
bal_psid <- cobalt::bal.tab(model, data = ldw_psid.plus, un = TRUE, weights = methods_psid, s.d.denom = "treated")
```

#### SMD
```{r}
#| code-fold: show
smd_matchit_cps <- compute_abs_smd_matchit(methods_cps)
smd_matchit_psid <- compute_abs_smd_matchit(methods_psid)
```

#### Effective Sample Sizes 
```{r}
#| code-fold: show
ess_matchit_cps <- compute_ess_matchit(bal_cps)
ess_matchit_psid <- compute_ess_matchit(bal_psid)
```

#### Visuals
```{r}
#| code-fold: show
plot_matchit(methods_cps, "LDW-CPS1-PLUS")
plot_matchit(methods_psid, "LDW-PSID1-PLUS")
```

### Trimming
Methods
```{r}
#| code-fold: show
trim_cps <- list(
  original     = ldw_cps.plus,      
  common_range = ldw_cps_common,      
  crump        = ldw_cps_crump,      
  stuermer     = ldw_cps_stuermer,     
  walker       = ldw_cps_walker    
)

trim_psid <- list(
  original     = ldw_psid.plus,
  common_range = ldw_psid_common,
  crump        = ldw_psid_crump,
  stuermer     = ldw_psid_stuermer,
  walker       = ldw_psid_walker
)

```

#### SMD
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
smd_trim_cps <- compute_abs_smd_trim(trim_cps, "treat", covar)
smd_trim_psid <- compute_abs_smd_trim(trim_psid, "treat", covar)
```

#### ESS
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
ess_trim_cps <- compute_ess_trim(trim_cps, "treat", covar)
ess_trim_psid <- compute_ess_trim(trim_psid, "treat", covar)
```

#### Visuals
```{r}
#| code-fold: show
plot_trim(trim_cps, treat, covar)
plot_trim(trim_psid, treat, covar)
```

```{r}
#| code-fold: show
love.plot(ldw_cps.plus, ldw_cps_common,  treat = treat, covar = covar, title = "Covariate Balance of LDW-CPS1-PLUS (Common Range)")
love.plot(ldw_cps.plus, ldw_cps_crump,   treat = treat, covar = covar, title = "Covariate Balance of LDW-CPS1-PLUS after Crump Trimming") 
love.plot(ldw_cps.plus, ldw_cps_stuermer, treat = treat, covar = covar, title = "Covariate Balance of LDW-CPS1-PLUS after Stürmer Trimming")
love.plot(ldw_cps.plus, ldw_cps_walker,  treat = treat, covar = covar, title = "Covariate Balance of LDW-CPS1-PLUS after Walker Trimming")

love.plot(ldw_psid.plus, ldw_psid_common,  treat = treat, covar = covar, title = "Covariate Balance of LDW-PSID1-PLUS (Common Range)")
love.plot(ldw_psid.plus, ldw_psid_crump,   treat = treat, covar = covar, title = "Covariate Balance of LDW-PSID1-PLUS after Crump Trimming")
love.plot(ldw_psid.plus, ldw_psid_stuermer, treat = treat, covar = covar, title = "Covariate Balance of LDW-PSID1-PLUS after Stürmer Trimming")
love.plot(ldw_psid.plus, ldw_psid_walker,  treat = treat, covar = covar, title = "Covariate Balance of LDW-PSID1-PLUS after Walker Trimming")
```

### Truncation
Methods
```{r}
#| code-fold: show
trunc_cps <- list(
  fix_max_value_trunc = ldw_cps_fixed,
  at_perc_trunc = ldw_cps_percent,
  adap_weight_trunc = ldw_cps_adapt
)

trunc_psid <- list(
  fix_max_value_trunc = ldw_psid_fixed,
  at_perc_trunc = ldw_psid_percent,
  adap_weight_trunc = ldw_psid_adapt
)
```

#### SMD
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
smd_trunc_cps <- compute_abs_smd_trunc(trunc_cps, "treat", covar, weight_columns)
smd_trunc_psid <- compute_abs_smd_trunc(trunc_psid, "treat", covar, weight_columns)
```

#### ESS
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
ess_trunc_cps <- compute_ess_trunc(trunc_cps, "treat", covar, weight_columns)
ess_trunc_psid <- compute_ess_trunc(trunc_psid, "treat", covar, weight_columns)
```

#### Visuals
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
plot_truncation_methods(trunc_cps, "treat", covar, weight_columns, "LDW-CPS1-PLUS")
plot_truncation_methods(trunc_psid, "treat", covar, weight_columns, "LDW-PSID1-PLUS")
```

### Weighting
Methods
```{r}
#| code-fold: show
weight_cps <- list(
  ipw      = ldw_cps.plus$ipw_weight,
  smr_tr   = ldw_cps.plus$smr_weight,
  smr_untr = ldw_cps.plus$smr_ate_weight,
  mw       = ldw_cps.plus$opt_weight,
  ow       = ldw_cps.plus$overlap_weight,
  ew       = ldw_cps.plus$ebal_weight
)

weight_psid <- list(
  ipw      = ldw_psid.plus$ipw_weight,
  smr_tr   = ldw_psid.plus$smr_weight,
  smr_untr = ldw_psid.plus$smr_ate_weight,
  mw       = ldw_psid.plus$opt_weight,
  ow       = ldw_psid.plus$overlap_weight,
  ew       = ldw_psid.plus$ebal_weight
)
```

#### SMD
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
smd_weight_cps <- compute_abs_smd_weight(ldw_cps.plus, "treat", covar, weight_columns)
smd_weight_psid <- compute_abs_smd_weight(ldw_psid.plus, "treat", covar, weight_columns)
```

#### ESS
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
ess_weight_cps <- compute_ess_weight(ldw_cps.plus, "treat", covar, weight_columns)
ess_weight_psid <- compute_ess_weight(ldw_psid.plus, "treat", covar, weight_columns)
```

#### Visuals
```{r, message=FALSE, warning=FALSE}
#| code-fold: show
plot_weighting_methods(ldw_cps.plus, "treat", covar, weight_cps, "LDW-CPS1-PLUS") 
plot_weighting_methods(ldw_psid.plus, "treat", covar, weight_psid, "LDW-PSID1-PLUS")
```

### Combined methods
```{r}
all_comb_cps <- list(
  ipw = ipw_comb_cps,
  smr_treated = smr_treat_comb_cps,
  smr_untreated = smr_untreat_comb_cps,
  overlap = ov_comb_cps,
  matching = matching_comb_cps,
  entropy = entropy_comb_cps
)

all_comb_psid <- list(
  ipw = ipw_comb_psid,
  smr_treated = smr_treat_comb_psid,
  smr_untreated = smr_untreat_comb_psid,
  overlap = ov_comb_psid,
  matching = matching_comb_psid,
  entropy = entropy_comb_psid
)

all_comb_datasets <- list(
  CPS  = all_comb_cps,
  PSID = all_comb_psid
)
```

#### SMD
```{r}
smd_all_comb <- compute_smd_all_datasets(all_comb_datasets, "treat", covar)
```

#### ESS
```{r}
ess_all_comb <- compute_ess_all_datasets(all_comb_datasets, "treat", covar)
```

#### Visuals
```{r, message=FALSE, warning=FALSE}
plot_comb_overlap_all_interactive(all_comb_datasets, "treat", covar)
```


```{r, message=FALSE, warning=FALSE}
plot_comb_love_plots(all_comb_datasets, "treat", covar)
```

### All results 
```{r}
all_cps.plus <- combine_results("CPS")
all_psid.plus <- combine_results("PSID")

print("CPS1-PLUS Results:")
print(all_cps.plus)
print("PSID1-PLUS Results:")
print(all_psid.plus)

# save results 
write.csv(all_cps.plus, "CPS1_PLUS_resultsmodel_a.csv", row.names = FALSE)
write.csv(all_psid.plus, "PSID1_PLUS_resultsmodel_a.csv", row.names = FALSE)
```

### Top methods and datasets
Assess all methods and create score
- smd_score rescales Mean_Abs_SMD to a 0-1 range where lower Mean_Abs_SMD leads to a higher score
- ess_score measures sample size effectiveness by combining effective sample sizes (Control + Treated) and normalizing between 0 and 1
```{r}
ranked_cps.plus  <- assess_methods(all_cps.plus)
ranked_psid.plus <- assess_methods(all_psid.plus)
```

Rank the results and get only the top 5
```{r}
top5_cps_methods <- get_top_methods(ranked_cps.plus, top_n = 5)
top5_psid_methods <- get_top_methods(ranked_psid.plus, top_n = 5)
```

```{r}
# create combined lists of all methods
comb_cps_methods <- c(methods_cps, trim_cps, trunc_cps, weight_cps, all_comb_cps)
comb_psid_methods <- c(methods_psid, trim_psid, trunc_psid, weight_psid, all_comb_psid)

# create the datasets from combined lists for your top 5 methods:
top5_cps_datasets <- create_top5_datasets(comb_cps_methods, top5_cps_methods)
top5_psid_datasets <- create_top5_datasets(comb_psid_methods, top5_psid_methods)

# save them in a .RData file
save_top5_individual_files(comb_cps_methods, top5_cps_methods, prefix = "model_a_cps")
save_top5_individual_files(comb_psid_methods, top5_psid_methods, prefix = "model_a_psid")
```

## Estimate the ATT

Next we process with the estimation of the ATT using both the LDW-Experimental data and the newly constructed top 5 samples that produced best overlap. 
```{r}
top5_cps_datasets <- lapply(1:5, load_top_method_dataset, prefix = "model_a_cps")
top5_psid_datasets <- lapply(1:5, load_top_method_dataset, prefix = "model_a_psid")
```

```{r}
out1 <- estimate_all(ldw, "re78", "treat", covar)
out2 <- estimate_all(ldw_cps, "re78", "treat", covar)
out3 <- estimate_all(ldw_psid, "re78", "treat", covar)
```

```{r, message=FALSE, warning=FALSE}
out_cps <- lapply(top5_cps_datasets, function(d) estimate_all(d, "re78", "treat", covar))
out_psid <- lapply(top5_psid_datasets, function(d) estimate_all(d, "re78", "treat", covar))
```

```{r}
out4 <- out_cps[[1]]
out5 <- out_cps[[2]]
out6 <- out_cps[[3]]
out7 <- out_cps[[4]]
out8 <- out_cps[[5]]

out9 <- out_psid[[1]]
out10 <- out_psid[[2]]
out11 <- out_psid[[3]]
out12 <- out_psid[[4]]
out13 <- out_psid[[5]]
```


```{r}
# build plot titles 
base_titles <- c("(1) LDW-Experimental", "(2) LDW-CPS1", "(3) LDW-PSID1")
top5_cps_titles <- paste0("(", 4:(3 + length(top5_cps_methods)), ") Top CPS1: ", top5_cps_methods)
top5_psid_titles <- paste0("(", (4 + length(top5_cps_methods)):(3 + length(top5_cps_methods) + length(top5_psid_methods)), ") Top PSID1: ", top5_psid_methods)

plot_titles <- c(base_titles, top5_cps_titles, top5_psid_titles)

band <- out1[1, 3:4]
est  <- out1[1, 1]
```

```{r, out.width='100%', fig.asp=1, fig.cap="FIGURE 3. ATT Estimates Given Unconfoundedness: LDW Samples"}
# combine all results
all_outs <- list(out1, out2, out3, out4, out5, out6, out7, out8, out9, out10, out11, out12, out13)

# plot results
plot_att_panels(all_outs, base_titles, top5_cps_methods, top5_psid_methods, band, est)
```

The above figures show the ATT estimates and their 95% confidence intervals using 13 samples: LDW-Experimental, LDW-CPS1-PLUS, LDW-PSID1-PLUS, the Top 5 CPS1-PLUS methods, and the Top 5 PSID1-PLUS methods.

Figure (1) presents the benchmark from the experimental sample (LDW-Experimental). Figures (2) and (3) show results for the full combined observational samples, LDW-CPS1-PLUS and LDW-PSID1-PLUS, respectively. Figures (4) to (8) display estimates for the Top 5 methods ranked for CPS1-PLUS. Figures (9) to (13) display estimates for the Top 5 methods ranked for PSID1-PLUS.

In most CPS1-PLUS samples (Figures 4–8), all estimators except difference-in-means, IPW and CBPS tend to yield positive ATT estimates. Many methods—including profile, mahalanobis, optimal pair, and cardinality matching—produce results tightly clustered around the experimental benchmark. 

In most PSID1-PLUS samples (Figures 9–13), all estimators except difference-in-means, IPW and CBPS tend to yield positive ATT estimates but exhibit greater estimator variability —including both larger standard errors and greater instability in point estimates— than the CPS1-PLUS samples.


The ATT results are presented in the table below:
```{r class.source = 'fold-hide'}
# define column headers for each sample (matching your figure captions)
sample_names <- c(
  "LDW-Experimental", "LDW-CPS1", "LDW-PSID1",
  "Top1 CPS", "Top2 CPS", "Top3 CPS",
  "Top4 CPS", "Top5 CPS",
  "Top1 PSID", "Top2 PSID", "Top3 PSID",
  "Top4 PSID", "Top5 PSID"
)

# get result matrix
result_mat <- create_matrix_results(all_outs, sample_names)
knitr::kable(result_mat, booktabs = TRUE, caption = "ATT Estimates and SEs for All Samples and Estimators")
```

## Alternative Estimands: CATT and QTET
### Conditional Average Treatment Effect on the Treated (CATT)
```{r, warning=FALSE}
#| code-fold: show
catt.ldw <- catt(ldw, Y, treat, covar)
catt.cps <- catt(ldw_cps, Y, treat, covar)
catt.psid <- catt(ldw_psid, Y, treat, covar)
```

```{r, warning=FALSE}
#| code-fold: show
catt_top5_cps <- lapply(top5_cps_datasets, function(d) catt(d, Y, treat, covar))
catt_top5_psid <- lapply(top5_psid_datasets, function(d) catt(d, Y, treat, covar))
```

```{r, out.width='100%', fig.asp=1, fig.cap="FIGURE 4. CATT Estimates using LDW Data: Experimental vs. Nonexperimental"}
#| code-fold: show
# combine all catt objects in order 
all_catt <- c(list(catt.ldw, catt.cps, catt.psid), catt_top5_cps, catt_top5_psid)

# plot results
plot_catt_panels(all_catt, plot_titles, plots_per_page = 4, range = c(-8000, 8000))
```

### Quantile Treatment Effect on the Treated (QTET)
```{r, warning=FALSE}
#| code-fold: show
qte.ldw <- est_qte(Y, treat, covar, data = ldw)
```

```{r, warning=FALSE}
#| code-fold: show
qte.ldw.cps <- est_qte(Y, treat, covar, data = ldw_cps)
qte.ldw.psid <- est_qte(Y, treat, covar, data = ldw_psid)
```

```{r, warning=FALSE}
#| code-fold: show
qte.top5.cps  <- lapply(top5_cps_datasets,  function(d) est_qte(Y, treat, covar, data = d))
qte.top5.psid <- lapply(top5_psid_datasets, function(d) est_qte(Y, treat, covar, data = d))
```

```{r, warning=FALSE}
#| code-fold: show
qte.ldw0 <- est_qte(Y, treat, NULL, data = ldw)
qte.ldw.cps0 <- est_qte(Y, treat, NULL, data = ldw_cps)
qte.ldw.psid0 <- est_qte(Y, treat, NULL, data = ldw_psid)
```

```{r, warning=FALSE}
#| code-fold: show
qte.top5.cps0  <- lapply(top5_cps_datasets,  function(d) est_qte(Y, treat, NULL, data = d))
qte.top5.psid0 <- lapply(top5_psid_datasets, function(d) est_qte(Y, treat, NULL, data = d))
```

```{r}
#| code-fold: show
# combine all qte objects in order 
all_qtet <- c(list(qte.ldw, qte.ldw.cps, qte.ldw.psid), qte.top5.cps, qte.top5.psid)

# plot results
plot_qtet_panels(all_qtet, plot_titles, experimental_qte = qte.ldw, plots_per_page = 4, ylim = c(-25000, 15000))
```

## Validation through Placebo Analyses

To further evaluate the credibility of the unconfoundedness assumption, a placebo analysis is performed by designating 1975 earnings (re75) as the outcome variable and omitting both re75 and u75 from the list of adjustment covariates. The analysis utilizes all previously considered datasets, excluding re75 and u75 from the model. Using these new samples, the ATT is then recomputed with the `estimate_all`-function, conditioning only on the remaining set of covariates.

```{r, warning=FALSE}
#| code-fold: show
Y_pl <- "re75"
treat <- "treat"
covar_pl <- c("age", "education", "black", "hispanic", "married", "nodegree", "re74", "u74")
```

```{r, warning=FALSE}
#| code-fold: show
out1_pl <- estimate_all(ldw, Y_pl, "treat", covar_pl)
out2_pl <- estimate_all(ldw_cps, Y_pl, "treat", covar_pl)
out3_pl <- estimate_all(ldw_psid, Y_pl, "treat", covar_pl)
```

```{r, message=FALSE, warning=FALSE}
#| code-fold: show
out_cps_pl <- lapply(top5_cps_datasets, function(d) estimate_all(d, Y_pl, "treat", covar_pl))
out_psid_pl <- lapply(top5_psid_datasets, function(d) estimate_all(d, Y_pl, "treat", covar_pl))
out4_pl <- out_cps_pl[[1]]
out5_pl <- out_cps_pl[[2]]
out6_pl <- out_cps_pl[[3]]
out7_pl <- out_cps_pl[[4]]
out8_pl <- out_cps_pl[[5]]
out9_pl <- out_psid_pl[[1]]
out10_pl <- out_psid_pl[[2]]
out11_pl <- out_psid_pl[[3]]
out12_pl <- out_psid_pl[[4]]
out13_pl <- out_psid_pl[[5]]
```

```{r}
#| code-fold: show
all_outs_pl <- list(out1_pl, out2_pl, out3_pl, out4_pl, out5_pl, out6_pl, out7_pl, out8_pl, out9_pl, out10_pl, out11_pl, out12_pl, out13_pl)
band_pl <- out1_pl[1, 3:4]
est_pl  <- out1_pl[1, 1]
ylim_pl <- c(-12000, 2000)
plot_att_panels(all_outs_pl, base_titles, top5_cps_methods, top5_psid_methods, band_pl, est_pl, ylim = ylim_pl)
```

The *Placebo* ATT results are presented in the table below:

```{r class.source = 'fold-hide'}
all_outs_pl <- list(
  out1_pl, out2_pl, out3_pl,
  out4_pl, out5_pl, out6_pl, out7_pl, out8_pl,
  out9_pl, out10_pl, out11_pl, out12_pl, out13_pl
)

result_mat_pl <- create_matrix_results(all_outs_pl, sample_names)
knitr::kable(result_mat_pl, booktabs = TRUE, caption = "Placebo ATT Estimates and SEs for All Samples and Estimators")
```
The first row of the table demonstrates that the experimental benchmark for 1975 earnings is near zero and statistically insignificant, while all estimators applied to observational and matched datasets yield large, negative estimates, confirming that placebo analysis reveals substantial bias and deviation from the true effect across all non-experimental samples.

## Sensitivity Analyses

Now we also conduct a sensitivity analyses using the LDW data, and depict the results in contour plots below using the `sens_ana`-function.

```{r, warning=FALSE}
#| code-fold: show
Y <- "re78"
treat <- "treat"
covar <- c("age", "education", "black", "hispanic", "married", "nodegree", "re74", "re75", "u74", "u75")
bm <- c("re75") 
```

```{r, warning=FALSE}
#| code-fold: show
# Check for valid datasets 
datasets_sens <- c(list(ldw, ldw_cps, ldw_psid), top5_cps_datasets, top5_psid_datasets)
filtered_datasets_sens <- check_filter_datasets(datasets_sens, Y, treat, covar, bm)
```

```{r, warning=FALSE}
#| code-fold: show
# loop over valid datasets 
for (i in seq_along(filtered_datasets_sens)) {
    # find correct index 
    idx <- which(sapply(datasets_sens, identical, filtered_datasets_sens[[i]]))
    sens_ana(filtered_datasets_sens[[i]], Y, treat, covar, bm, kd = 1:3)
    title(main = plot_titles[idx])
}
```

::: callout-tip
The analyses suggest that the estimated training effect based on LDW-CPS is less sensitive to potential confounders compared to trimmed LDW-PSID. 
:::

# Summary

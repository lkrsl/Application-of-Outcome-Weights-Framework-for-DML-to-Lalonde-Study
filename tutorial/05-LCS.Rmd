# LaLonde-Calónico-Smith (LCS) Data 

This section (5) examines the LaLonde female samples reconstructed by @calonico_smith_2017, referred to as the LaLonde-Calónico-Smith (LCS) sample (loaded as `lcs` below, similar to @imbens2024). 

For detailed explanations of the analysis steps and notes, please refer to section 2. Here, we only present and explain the LCS–specific results.

## Set up
### Source functions and load data
```{r, message=FALSE, warning=FALSE}
# source functions
source("https://github.com/xuyiqing/lalonde/blob/main/tutorial/functions.R?raw=TRUE")
source("tutorial/functions.R")
```

```{r, message=FALSE, warning=FALSE}
# load data
load("data/lcs.RData")
```

```{r, message=FALSE, warning=FALSE}
# set seed
set.seed(42)
```

### Load and preprocess data 
```{r, message=FALSE, warning=FALSE}
# expc = 0: experimental treated; 
# expc = 1: experimental control; 
# expc = 2: psid control;

lcs_psid$expc <- 0 
lcs_psid[lcs_psid$treat==0, ]$expc <- 2 
lcs_tr <- lcs[lcs$treat==1, ]
lcs_co <- lcs[lcs$treat==0, ]
lcs_co$treat <- 1
lcs_co$expc <- 1
lcs_psid_plus <- rbind.data.frame(lcs_psid, lcs_co)
```

### Inspect data
```{r, message=FALSE, warning=FALSE}
# collect datasets in a list
data <- list(lcs = lcs, lcs_psid = lcs_psid, lcs_psid_plus = lcs_psid_plus)

# inspect key metrics of each dataset
summary_stats <- inspect_data(data)
datatable(summary_stats, caption = "Summary Statistics",
          options = list(scrollX = TRUE, paging = FALSE, pageLength = -1, searching = FALSE))
```

## Model
```{r, message=FALSE, warning=FALSE}
# define variables
Y <- "re79"
treat <- "treat"
# redefine covariates: removing "nchildren75" to be used as placebo outcome
covar <- c("age", "educ", "nodegree", "married", "black", "hisp", 
           "re75", "u75")
```

<div class="callout-note">
In the following analysis, only PSID1 data is used as the original LaLonde study and its reconstruction by Calónico and Smith (2017) designate PSID1 as the appropriate nonexperimental control group for women, providing a comparable observational dataset that aligns with the experimental sample’s characteristics.
</div>

### Assessing overlap and covariate balance
#### Overlap
```{r, message=FALSE, warning=FALSE, fig.cap='FIGURED1. SubfigureA:LCS-Experimental. SubfigureB:LCS-PSID1.',out.width='100%', fig.asp=0.5}
lcs.ps <- assess_overlap(data = lcs, treat = treat, cov = covar, xlim = c(-1.5, 1.5), breaks = 40)
lcs_psid.ps <- assess_overlap(data = lcs_psid, treat = treat, cov = covar, xlim = c(-11, 7), breaks = 40)
```

As anticipated, the LCS-Experimental data exhibit an almost perfect overlap. In contrast, the observational dataset LCS-PSID1 displays weak overlap. 
```{r, message=FALSE, warning=FALSE, fig.cap='FIGURED1. SubfigureC:LCS-PSID1-PLUS.', out.width='80%', fig.asp=1, fig.align='center'}
lcs_psid_plus.ps <- assess_overlap(data = lcs_psid_plus, treat = treat, cov = covar, xlim = c(-15, 5))
```

With the expanded dataset LCS-PSID1, it is evident that the degree of overlap between treated and control groups has improved, as seen by a greater spread of log-odds densities across both samples.

```{r, message=FALSE, warning=FALSE}
# set model formula
model <- as.formula(paste(treat, "~", paste(covar, collapse = " + ")))
```

#### Covariate balance
```{r, warning=FALSE, message=FALSE, fig.cap='FIGURED2. SubfigureA:LDW-PSID1. SubfigureB:LDW-PSID1-PLUS.', out.width='80%', fig.asp=1, fig.align='center'}
plot_balance(lcs, lcs_psid, treat, covar = covar, title = "LCS-PSID1")
plot_balance(lcs, lcs_psid_plus, treat, covar = covar, title = "LCS-PSID1-PLUS")
```

<div class="callout-note">
Due to computational constraints, we use a reduced set of matching methods, consistent with previous sections.
</div>

## Improving primarily covariate balance
### Matching 
#### Distance Matching
##### Optimal pair matching
```{r, message=FALSE, warning=FALSE}
# perform optimal pair matching that minimizes total within-pair distance on propensity scores
m.out.psid.optimal_pair <- matchit(model, data = lcs_psid, method = "optimal", distance = "glm", link = "logit")
```

##### Optimal full matching
```{r, message=FALSE, warning=FALSE}
# perform optimal full matching allowing sets with varying ratios of treated to controls and minimizing a global distance criterion
m.out.psid.optimal_full <- matchit(model, data = lcs_psid, method = "full", distance = "glm", link = "logit")
```

#### Stratum matching
##### Coarsened matching (cem)
Strata = coarsened versions of covariates
```{r, message=FALSE, warning=FALSE}
# match units exactly within coarse strata 
m.out.psid.cem <- matchit(model, data = lcs_psid, method = "cem")
```

##### Subclassification 
Strata = bins of the propensity score
```{r, message=FALSE, warning=FALSE}
# partition sample into fixed number of bins based on propensity score 
m.out.psid.subcl <- matchit(model, data = lcs_psid, method = "subclass", subclass = 5)
```

#### Pure subset selection
##### Cardinality profile matching
```{r, message=FALSE, warning=FALSE}
# select largest balanced subsample meeting covariate balance tolerances and a fixed ratio of controls to treated units
m.out.psid.card <- matchit(model, data = lcs_psid, method = "cardinality", tols = 0.1, ratio = 1, time = 1200)
```

##### Profile matching
```{r, message=FALSE, warning=FALSE}
# select the largest control group subset balanced to the treated group (for ATT), leaving the treated group intact
m.out.psid.profile <- matchit(model, data = lcs_psid, method = "cardinality", estimand = "ATT", tols = 0.1, ratio = NA, time = 1200)
```

### Weighting
#### Inverse probability weights (IPW)
```{r, message=FALSE, warning=FALSE}
# estimates propensity scores with a parametric generalized linear model and converts them into weights
w.out.psid.ipw <- WeightIt::weightit(model, data = lcs_psid, estimand = "ATT", method = "glm")
lcs_psid.ps$ipw_weight <- w.out.psid.ipw$weights
```

#### Covariate balance propensity score weights
```{r, message=FALSE, warning=FALSE}
# estimates propensity scores using generalized method of moments and then converts them into weights
w.out.psid.cbps <- WeightIt::weightit(model, data = lcs_psid, estimand = "ATT", method = "cbps")
lcs_psid.ps$cbps_weight <- w.out.psid.cbps$weights
```

#### Stable balancing weights 
```{r, message=FALSE, warning=FALSE}
# estimates weights by solving a quadratic programming problem 
w.out.psid.opt <- WeightIt::weightit(model, data = lcs_psid, estimand = "ATT", method = "optweight")
lcs_psid.ps$opt_weight <- w.out.psid.opt$weights
```

#### Entropy balancing weights
```{r, message=FALSE, warning=FALSE}
# estimates weights by minimizing the negative entropy of the weights subject to exact moment balancing constraints
w.out.psid.ebal <- WeightIt::weightit(model, data = lcs_psid, estimand = "ATT", method = "ebal")
lcs_psid.ps$ebal_weight <- w.out.psid.ebal$weights
```

## Improving primarily overlap
#### Fixed value truncation
```{r, message=FALSE, warning=FALSE}
# truncate weights by imposing a minimum and maximum 
lcs_psid.ps_fixed <- truncate_ps_fixed(lcs_psid.ps, treat = "treat", ps = "ps_assoverlap", lower = 0.05, upper = 0.95)
```

#### At percentile truncation
```{r, message=FALSE, warning=FALSE}
# truncate weights such that values below the 5th percentile and above the 95th percentile are capped
lcs_psid.ps_percent <- truncate_ps_percentile(lcs_psid.ps, ps = "ps_assoverlap", lower_percentile = 5, upper_percentile = 95)
```

#### Adaptive weight truncation
```{r, message=FALSE, warning=FALSE}
# truncate weights using data-driven quantile selection
lcs_psid.ps_adapt <- truncate_ps_adaptive(lcs_psid.ps, treat = "treat", ps = "ps_assoverlap", folds = 5,
                                         lower_grid = seq(0.01, 0.10, by = 0.01),
                                         upper_grid = seq(0.90, 0.99, by = 0.01))
```

### Trimming 
#### Propensity score threshold trimming 
```{r, message=FALSE, warning=FALSE}
# apply trimming with threshold 0.9
lcs_psid.ps_trim <- ps_trim(lcs_psid.ps, threshold = 0.9)

# re-estimate propensity scores on trimmed data 
lcs_psid.ps_trim <- ps_estimate(data = lcs_psid.ps_trim, treat = treat, cov = covar)
```

#### Common range trimming
```{r, message=FALSE, warning=FALSE}
# trim observations outside the common support region of propensity scores
lcs_psid.ps_common  <- common_range_trim(lcs_psid.ps)

# re-estimate propensity scores on trimmed data 
lcs_psid.ps_common <- ps_estimate(data = lcs_psid.ps_common, treat = treat, cov = covar)
```

#### Crump trimming 
```{r, message=FALSE, warning=FALSE}
# trim observations with propensity scores outside [0.1, 0.9] interval
lcs_psid.ps_crump <- crump_trim(lcs_psid.ps, lower = 0.1, upper = 0.9)

# re-estimate propensity scores on trimmed data 
lcs_psid.ps_crump <- ps_estimate(data = lcs_psid.ps_crump, treat = treat, cov = covar)
```

#### Stuermer trimming
```{r, message=FALSE, warning=FALSE}
# trim observations based on propensity score quantiles separately for treated and control
lcs_psid.ps_stuermer <- stuermer_trim(lcs_psid.ps)

# re-estimate propensity scores on trimmed data 
lcs_psid.ps_stuermer <- ps_estimate(data = lcs_psid.ps_stuermer, treat = treat, cov = covar)
```

#### Walker trimming
```{r, message=FALSE, warning=FALSE}
# trim observations based on preference scores that adjust for treatment prevalence using logit transformations
lcs_psid.ps_walker <- walker_trim(lcs_psid.ps)

# re-estimate propensity scores on trimmed data 
lcs_psid.ps_walker <- ps_estimate(data = lcs_psid.ps_walker, treat = treat, cov = covar)
```

## Integrated methods
### Trimming and matching
#### Propensity score threshold trimming and nn matching
(Similar to tutorial of @imbens2024)
```{r, message=FALSE, warning=FALSE}
# apply trimming with threshold 0.9
lcs_psid_trim <- ps_trim(lcs_psid_plus.ps, threshold = 0.9)

# exclude experimental controls
lcs_psid_trim_match <- subset(lcs_psid_trim, expc %in% c(0, 2) & ps_assoverlap)

# re-estimate propensity scores and employ 1:1 matching
lcs_psid_trim_match <- psmatch(data = lcs_psid_trim_match, Y = "re79", treat = "treat", cov = covar)

# trim experimental data
lcs_trim_psid <- subset(lcs_psid_trim, expc %in% c(0, 1))
lcs_trim_psid$treat[which(lcs_trim_psid$expc == 1)] <- 0
```

### Trimming and weighting
```{r, message=FALSE, warning=FALSE}
# list trimming objects
all_trim.psid  <- list(ps_threshold = lcs_psid.ps_trim, 
                     common_range = lcs_psid.ps_common, 
                     stuermer = lcs_psid.ps_stuermer, 
                     walker = lcs_psid.ps_walker, 
                     crump = lcs_psid.ps_crump)
```

#### IPW with 1) propensity threshold 2) common range 3) stuermer 4) walker 5) crump
```{r, message=FALSE, warning=FALSE}
# apply inverse probability weighting (IPW) with trimming and attach IPW weights
ipw_comb.psid <- attach_weights(all_trim.psid, model, "ipw_weight")
```

#### Stable balancing weights with 1) propensity threshold 2) common range 3) stuermer 4) walker 5) crump
```{r, message=FALSE, warning=FALSE}
# apply stable balancing with trimming and attach stable balance weights
opt_comb.psid <- attach_weights(all_trim.psid, model, "opt_weight")
```

#### Propensity score weights with 1) propensity threshold 2) common range 3) stuermer 4) walker 5) crump
```{r, message=FALSE, warning=FALSE}
# apply propensity score weighting with trimming and attach propensity score weights
cbps_comb.psid <- attach_weights(all_trim.psid, model, "cbps_weight")
```

#### Entropy balancing weights with 1) propensity threshold 2) common range 3) stuermer 4) walker 5) crump
```{r, message=FALSE, warning=FALSE}
# apply entropy balancing weights with trimming and attach entropy weights
ebal_comb.psid <- attach_weights(all_trim.psid, model, "ebal_weight")
```

### Truncation and weighting
```{r, message=FALSE, warning=FALSE}
# list weight columns to apply truncation 
weight_columns <- c("ipw_weight", "opt_weight", "cbps_weight", "ebal_weight")
```

#### IPW, stable balancing, propensity score and entropy weights with 1) fixed maximum value truncation
```{r, message=FALSE, warning=FALSE}
# truncate weights by imposing a minimum and maximum threshold
fixed_comb.psid <- lcs_psid.ps
for (wcol in weight_columns) {
  if (wcol %in% names(fixed_comb.psid)) {
    fixed_comb.psid <- truncate_weights_fixed(fixed_comb.psid, weight_col = wcol, lower = 0.025, upper = 0.975)
  }
}
```

#### IPW, stable balancing, propensity score and entropy weights with 2) at percentile truncation
```{r, message=FALSE, warning=FALSE}
# truncate weights such that values below the 5th percentile and above the 95th percentile are capped
percent_comb.psid <- lcs_psid.ps
for (wcol in weight_columns) {
  if (wcol %in% names(percent_comb.psid)) {
    percent_comb.psid <- truncate_weights_percentile(percent_comb.psid, weight_col = wcol, lower = 0.05, upper = 0.95)
  }
}
```

#### IPW, stable balancing, propensity score and entropy weights with 3) adaptive weight truncation
```{r, message=FALSE, warning=FALSE}
# truncate weights using data-driven quantile selection
adapt_comb.psid <- lcs_psid.ps
for (wcol in weight_columns) {
  if (wcol %in% names(adapt_comb.psid)) {
    adapt_comb.psid <- truncate_weights_adaptive(adapt_comb.psid, weight_col = wcol)
  }
}
```

## Reassessing methods
### Matching
```{r, message=FALSE, warning=FALSE}
# list all matching objects
all_match.psid <- list(
  optimal_pair = m.out.psid.optimal_pair,
  optimal_full = m.out.psid.optimal_full,
  cem = m.out.psid.cem,
  card = m.out.psid.card,
  profile = m.out.psid.profile,
  subcl = m.out.psid.subcl
)
```

#### SMD
```{r, message=FALSE, warning=FALSE}
# compute absolute SMD
smd_matchit.psid <- compute_abs_smd_matchit(all_match.psid)
```

#### OVL
```{r, message=FALSE, warning=FALSE}
# calculate overlap coefficient
ovl_matchit.psid <- compute_ovl_matchit(all_match.psid, ps_col = "distance", treat_col = "treat", covar = covar)
```

### Weighting
```{r, message=FALSE, warning=FALSE}
# list all weights
all_weight.psid <- list(
  ipw_weight = lcs_psid.ps$ipw_weight,
  opt_weight = lcs_psid.ps$opt_weight,
  cbps_weight = lcs_psid.ps$cbps_weight,
  ebal_weight = lcs_psid.ps$ebal_weight
)
```

#### SMD
```{r, message=FALSE, warning=FALSE}
# compute absolute SMD
smd_weight.psid <- compute_abs_smd_weight(lcs_psid.ps, treat, covar, all_weight.psid)
```

#### OVL 
```{r message=FALSE, warning=FALSE}
# compute overlap coefficients
ovl_weight.psid <- compute_ovl_weight(data = lcs_psid.ps, treat_col = "treat", ps_col = "ps_assoverlap", weights_list = all_weight.psid, covar = covar, n_points = 512)
```

### Truncation
```{r, message=FALSE, warning=FALSE}
# list truncation methods
all_trunc.psid <- list(
  fix_value = lcs_psid.ps_fixed,
  at_perc = lcs_psid.ps_percent,
  adapt = lcs_psid.ps_adapt
)
```

#### SMD
```{r, message=FALSE, warning=FALSE}
# compute absolute SMD
smd_trunc.psid <- compute_abs_smd_trunc(all_trunc.psid, "treat", covar, "ps_assoverlap")
```

#### OVL
```{r, message=FALSE, warning=FALSE}
# compute overlap coefficients
ovl_trunc.psid <- compute_ovl_trunc(all_trunc.psid, "ps_assoverlap", "treat")
```

### Trimming
```{r, message=FALSE, warning=FALSE}
# list trimming object plus original
all_trim.psid <- list(
  original = lcs_psid.ps,
  ps_threshold = lcs_psid.ps_trim,
  common_range = lcs_psid.ps_common,
  crump = lcs_psid.ps_crump,
  stuermer = lcs_psid.ps_stuermer,
  walker = lcs_psid.ps_walker
)
```

#### SMD
```{r, message=FALSE, warning=FALSE}
# compute absolute SMD
smd_trim.psid <- compute_abs_smd_trim(all_trim.psid, "treat", covar)
```

#### OVL
```{r, message=FALSE, warning=FALSE}
# compute overlap coefficients
ovl_trim.psid <- compute_ovl_trim(all_trim.psid, "ps_assoverlap", "treat")
```

## Integrated methods
### Trimming and matching
(Similar to tutorial by @imbens2024)
```{r, message=FALSE, warning=FALSE}
# list all trimmed and matched samples
trim_match_comb.psid <- list(
  ps_threshold_match = lcs_psid_trim_match
)
```

#### SMD
```{r, message=FALSE, warning=FALSE}
# compute absolute SMD
smd_trim_match_comb.psid <- compute_abs_smd_trim(trim_match_comb.psid, "treat", covar)
```

#### OVL
```{r, message=FALSE, warning=FALSE}
# compute overlap coefficients
ovl_trim_match_comb.psid <- compute_ovl_trim_match(trim_match_comb.psid, ps_col = "distance", treat_col = "treat", covar = covar)
```

### Trimming and weighting
```{r, message=FALSE, warning=FALSE}
# list all combined results
trim_weight_comb.psid <- list(
  ipw = ipw_comb.psid,
  opt = opt_comb.psid,
  cbps = cbps_comb.psid,
  ebal = ebal_comb.psid
)
```

#### SMD
```{r, message=FALSE, warning=FALSE}
# compute absolute SMD
smd_trim_weight_comb.psid <- compute_abs_smd_trim_weight(trim_weight_comb.psid, "treat", covar)
```

#### OVL
```{r, message=FALSE, warning=FALSE}
# compute overlap coefficients
ovl_trim_weight_comb.psid <- compute_ovl_trim_weight(trim_weight_comb.psid, treat_col = "treat", ps_col = "ps_assoverlap")
```

### Truncation and weighting
```{r, message=FALSE, warning=FALSE}
# list all combined results
trunc_weight_comb.psid <- list(
  fix_value = fixed_comb.psid,
  at_perc = percent_comb.psid,
  adapt = adapt_comb.psid
)
```

#### SMD
```{r, message=FALSE, warning=FALSE}
# compute absolute SMD
smd_trunc_weight_comb.psid <- compute_abs_smd_trunc_weight(trunc_weight_comb.psid, "treat", covar, weight_columns)
```

#### OVL
```{r, message=FALSE, warning=FALSE}
# compute overlap coefficients
ovl_trunc_weight_comb.psid <- compute_ovl_trunc_weight(trunc_weight_comb.psid, treat_col = "treat", ps_col = "ps_assoverlap")
```

## Identifying best methods
### Ranking
#### Initial dataset
```{r, message=FALSE, warning=FALSE}
# combine all results
all_psid <- combine_results("psid") 

# save results 
save_csv(all_psid, "lcs_psid1_all_results")
```

```{r, message=FALSE, warning=FALSE}
# assess and rank methods
ranked_psid <- assess_methods(all_psid)

# get top 5 methods 
top5_methods.psid <- get_top_methods(ranked_psid, top_n = 5)

# save results 
save_csv(top5_methods.psid, "lcs_psid1_top5_methods")
```

```{r, message=FALSE, warning=FALSE}
# print results
top5_methods_df.psid <- ranked_psid %>% arrange(desc(Score)) %>% head(5)

datatable(top5_methods_df.psid, caption = "Top 5 Methods for PSID1",
          options = list(scrollX = TRUE, paging = FALSE, pageLength = -1, searching = FALSE))
```

#### Extended dataset
```{r, message=FALSE, warning=FALSE}
# combine results
all_psid_plus <- combine_results_plus("psid")

# save results 
save_csv(all_psid_plus, "lcs_psid1_plus_all_results")
```

```{r, message=FALSE, warning=FALSE}
# assess composite scores
ranked_psid_plus <- assess_methods(all_psid_plus)

# get top 5 methods 
top5_methods.psid_plus <- get_top_methods(ranked_psid_plus, top_n = 5)

# save results 
save_csv(top5_methods.psid_plus, "lcs_psid1_plus_top5_methods")
```

```{r, message=FALSE, warning=FALSE}
# print results
top5_methods_df.psid_plus <- ranked_psid_plus %>% arrange(desc(Score)) %>% head(5)

datatable(top5_methods_df.psid_plus, caption = "Top 5 Methods for PSID1 and PSID1-PLUS",
          options = list(scrollX = TRUE, paging = FALSE, pageLength = -1, searching = FALSE))
```

### Dataset construction
The table shows that for PSID1 the top methods include only matching and integrated approaches, with `card` as the best method.
```{r}
list_psid <- list(
  "All" = lcs_psid,
  "original" = lcs_psid.ps,
  "card" = m.out.psid.card,
  "optimal_full" = m.out.psid.optimal_full,
  "optimal_pair" = m.out.psid.optimal_pair,
  "subcl" = m.out.psid.subcl,
  "profile" = m.out.psid.profile,
  "ipw_weight" = lcs_psid.ps$ipw_weight, 
  "opt_weight" = lcs_psid.ps$opt_weight,
  "cbps_weight" = lcs_psid.ps$cbps_weight,
  "ebal_weight" = lcs_psid.ps$ebal_weight,
  "fix_value_ipw_weight" = fixed_comb.psid$ipw_weight,
  "fix_value_opt_weight" = fixed_comb.psid$opt_weight,
  "fix_value_cbps_weight" = fixed_comb.psid$cbps_weight,
  "fix_value_ebal_weight" = fixed_comb.psid$ebal_weight,
  "at_perc_ipw_weight" = percent_comb.psid$ipw_weight,
  "at_perc_opt_weight" = percent_comb.psid$opt_weight,
  "at_perc_cbps_weight" = percent_comb.psid$cbps_weight,
  "at_perc_ebal_weight" = percent_comb.psid$ebal_weight,
  "adapt_ipw_weight" = adapt_comb.psid$ipw_weight,
  "adapt_opt_weight" = adapt_comb.psid$opt_weight,
  "adapt_cbps_weight" = adapt_comb.psid$cbps_weight,
  "adapt_ebal_weight" = adapt_comb.psid$ebal_weight,
  "ps_threshold" = lcs_psid.ps_trim,
  "common_range" = lcs_psid.ps_common,
  "stuermer" = lcs_psid.ps_stuermer,
  "walker" = lcs_psid.ps_walker,
  "crump" = lcs_psid.ps_crump,
  "ipw_ps_threshold"= ipw_comb.psid[[1]],
  "ipw_common_range" = ipw_comb.psid[[2]],
  "ipw_stuermer"= ipw_comb.psid[[3]],
  "ipw_walker" = ipw_comb.psid[[4]],
  "ipw_crump"= ipw_comb.psid[[5]],
  "opt_ps_threshold" = opt_comb.psid[[1]],
  "opt_common_range" = opt_comb.psid[[2]],
   "opt_stuermer" = opt_comb.psid[[3]],
  "opt_walker" = opt_comb.psid[[4]],
  "opt_crump" = opt_comb.psid[[5]],
  "cbps_ps_threshold"  = cbps_comb.psid[[1]],
  "cbps_common_range" = cbps_comb.psid[[2]],
  "cbps_stuermer" = cbps_comb.psid[[3]],
  "cbps_walker"= cbps_comb.psid[[4]],
  "cbps_crump" = cbps_comb.psid[[5]],
  "ebal_ps_threshold" = ebal_comb.psid[[1]],
  "ebal_common_range" = ebal_comb.psid[[2]],
  "ebal_stuermer" = ebal_comb.psid[[3]],
  "ebal_walker" = ebal_comb.psid[[4]],
  "ebal_crump" = ebal_comb.psid[[5]],
  "ps_threshold_match" = lcs_psid_trim_match)
```

```{r, message=FALSE, warning=FALSE}
# create the datasets from combined lists for your top 5 methods:
top5_datasets.psid <- create_top5_datasets(list_psid, top5_methods.psid)
```

```{r, message=FALSE, warning=FALSE}
# save them into .RData files
save_top5_datasets(list_psid, top5_methods.psid, prefix = "lcs_psid1")
```

### Visuals
```{r, message=FALSE, warning=FALSE}
# visualize results
top5_objects.psid <- list_psid[top5_methods.psid]

# covariate balance
plot_weighting_balance(lcs_psid, treat, covar, top5_objects.psid, "PSID1 Top 5 Methods")

# overlap
# plot_weighting_overlap(lcs_psid, treat_col = "treat", weights_list = top5_objects.psid, covar = covar, prefix = "PSID1")
```

```{r, message=FALSE, warning=FALSE}
# save results
```

```{r, message=FALSE, warning=FALSE}
# visualize covariate balance of specific results (sort for type)
top5_objects.psid_plus <- list_psid[top5_methods.psid_plus]

# covariate balance
plot_weighting_balance(lcs_psid, treat, covar, top5_objects.psid_plus, "PSID1-PLUS Top 5 Methods")

# overlap 
# plot_weighting_overlap(lcs_psid, treat_col = "treat", weights_list = top5_objects.psid_plus, covar = covar, prefix = "PSID1-PLUS")
```

```{r, message=FALSE, warning=FALSE}
# save results 
```

## Estimating
### Average treatment effect on the treated (ATT)
```{r, message=FALSE, warning=FALSE}
# get estimates
out1 <- estimate_all(lcs, "re79", "treat", covar)
out2 <- estimate_all(lcs_psid, "re79", "treat", covar)

out.psid <- lapply(top5_datasets.psid, function(d) estimate_all(d, "re79", "treat", covar))
out3 <- out.psid[[1]]
out4 <- out.psid[[2]]
out5 <- out.psid[[3]]
out6 <- out.psid[[4]]
out7 <- out.psid[[5]]

load("data/lcs.RData")
out8 <- estimate_all(lcs_trim_psid, Y, "treat", covar)
out9 <- estimate_all(lcs_psid_trim, Y, "treat", covar)
```

```{r, message=FALSE, warning=FALSE, out.width='100%', fig.asp=1, fig.cap="FIGURED10. SubfigureA:LCS-Experimental. SubfigureB:LCS-PSID1. SubfigureC-G:Top-LCS-PSID1. SubfigureH:LCS-PSID1-PLUS. ATT Estimates Given Unconfoundedness using LCS Samples"}
par(mfrow = c(4, 1), mar = c(4, 4, 2, 1))

# experimental benchmarks
band.exp <- out1[1, 3:4]
est.exp  <- out1[1, 1]

# plot results
plot_coef(out1,  band = band.exp, line = est.exp, 
          ylim = c(-15500, 5500), main = "(A) LCS-Experimental")

plot_coef(out2,  band = band.exp, line = est.exp, 
          ylim = c(-15500, 5500), main = "(B) LCS-PSID1")

for (i in seq_along(out.psid)) {
  this_title <- paste0("(", LETTERS[i+2], ") Top PSID1: ", top5_methods.psid[i])
  plot_coef(out.psid[[i]], band = band.exp, line = est.exp,
            ylim = c(-15500, 5500), main = this_title)
}

# nonexperimtenal benchmarks
band.psid_plus <- out8[1, 3:4]
est.psid_plus <- out8[1, 1]

# plot results
plot_coef(out9, band = band.psid_plus, line = est.psid_plus, 
          ylim = c(-15500, 5500), main = "(H) Trimmed LCS-PSID1-PLUS")
```

```{r, message=FALSE, warning=FALSE}
# save results
save_att_panels(
  out_list = list(out1, out2),
  plot_titles = c("(A) LCS-Experimental", "(B) LCS-PSID1"),
  band_list = list(band.exp, band.exp),
  est_list  = list(est.exp, est.exp),
  prefix = "lcs_est_exp"
)

save_att_panels(
  out_list = out.psid,
  plot_titles = paste0("(", LETTERS[3:7], ") Top PSID1: ", top5_methods.psid),
  band_list = replicate(length(out.psid), band.exp, simplify = FALSE),
  est_list  = replicate(length(out.psid), est.exp, simplify = FALSE),
  prefix = "ldw_model_a_est_top_psid"
)

save_att_panels(
  out_list = list(out9),
  plot_titles = c("(H) Trimmed LCS-CPS1-PLUS"),
  band_list = list(band.psid_plus),
  est_list  = list(est.psid_plus),
  prefix = "ldw_model_a_est_plus"
)
```

The above figures show the ATT estimates and their 95% confidence intervals for eight samples: LCS-Experimental, LCS-PSID1, a series of top-ranked subsamples of LCS-PSID1 based on various matching, weighting, truncation, trimming or integrated criteria, as well as a trimmed version of the LCS-PSID1-PLUS sample (analogous to @imbens2024).

Figure (A) presents the benchmark from the experimental sample (LCS-Experimental), serving as a reference for bias and variance assessment of observational samples. Figures (B) shows results for the observational sample LCS-PSID1 and figures (C) through (G) display results for LCS-PSID1-based top-ranked subsamples. Figure (H) shows results for a trimmed version of LCS-PSID1-PLUS, replicating the tutorial results of Imbens & Xu (2024). 

Across the LCS-PSID1 dataset and its top-ranked subsamples, all estimators yield ATT estimates that largely cluster around the experimental benchmark except `Diff-in-Means`, which tends to produce estimates that deviate slightly more from the benchmark.
```{r, message=FALSE, warning=FALSE}
# get all outputs
all_outs <- c(list(out1, out2), 
              out.psid, 
              list(out9))

# get plot titles
all_plot_titles <- c("(A) LCS-Experimental", "(B) LCS-PSID1",
                      paste0("(", LETTERS[3:7], ") Top PSID1: ", top5_methods.psid),
                      "(H) Trimmed LCS-PSID1-PLUS")

# evaluate results
all_summaries <- lapply(all_outs, eval_att)
att_summary <- do.call(rbind, all_summaries)
rownames(att_summary) <- all_plot_titles

# print results
datatable(att_summary, caption = "ATT Summary Statistics",
          options = list(scrollX = TRUE, paging = FALSE, pageLength = -1, searching = FALSE))
```

The ATT results are presented in the table below:
```{r, message=FALSE, warning=FALSE}
# create result matrix
result_mat <- create_matrix_results(all_outs, all_plot_titles)

# render formatted table output
datatable(result_mat, caption = "ATT Estimates and SEs",
          options = list(scrollX = TRUE, paging = FALSE, pageLength = -1, searching = FALSE))
```

The tabulated results confirm visual patterns: Column (A) reports the estimates for the LCS-Experimental sample, column (B) for the LCS-PSID1 sample, columns (D)-(H) for the top-ranked subsample of LCS-PSID1, and column (C) for its trimmed version of LCS-PSID-PLUS.

For all PSID1-based samples, the ATT estimates remain overly positive. However, the estimates obtained with the `Diff-in-Means` estimator are consistently negative, except for the sample constructed with the `card` method, where the estimates are positive across all estimators.
```{r, message=FALSE, warning=FALSE}
# save results 
save_csv(result_mat, "lcs_att_est")
```

### Conditional average treatment effect on the treated (CATT)
```{r, warning=FALSE, message=FALSE}
catt.lcs <- catt(lcs, Y, treat, covar)
catt.psid <- catt(lcs_psid, Y, treat, covar)
catt.top5_psid <- lapply(top5_datasets.psid, function(d) catt(d, Y, treat, covar))
```

```{r, warning=FALSE, message=FALSE}
catt.lcs.psid <- catt(lcs_trim_psid, Y, treat, covar)
catt.psid.trim <- catt(lcs_psid_trim, Y, treat, covar)
```

```{r, message=FALSE, warning=FALSE, out.width='100%', fig.asp=1, fig.cap="FIGURED11. SubfigureB:LCS-PSID1. SubfigureC-G:Top-LCS-PSID1. SubfigureH:LCS-PSID1-PLUS. CATT Estimates using LCS Data: Experimental vs. Nonexperimental"}
# plot results
par(mfrow = c(2,2)) 
par(cex.main = 0.9)
plot_catt(
  catt1 = catt.lcs$catt,
  catt2 = catt.psid$catt,
  att1  = catt.lcs$att[1],
  att2  = catt.psid$att[1],
  xlab  = "CATT (Experimental)",
  ylab  = "CATT (CPS1)",
  main  = "(B) LCS-PSID1", 
  axes.range = c(-8000, 8000)
)

plot_catt_panels(
  exp_catt = catt.lcs,
  catt_list  = catt.top5_psid,
  plot_titles = paste0("(", LETTERS[3:7], ") Top PSID1: ", top5_methods.psid)
)

plot_catt(
  catt1 <- catt.lcs.psid$catt,
  catt2 <- catt.psid.trim$catt,
  att1 <- catt.lcs.psid$att[1],
  att2 <- catt.psid.trim$att[1],
  xlab  = "CATT (Experimental)",
  ylab  = "CATT (PSID1-PLUS-Trimmed)",
  main  = "(H) Trimmed LCS-PSID1-PLUS",
  axes.range = c(-8000, 8000)
)
```

```{r, message=FALSE, warning=FALSE, out.width='100%', fig.asp=1, fig.cap="FIGURED12. CATT Estimates using LCS Data"}
# combine all catt objects 
all_catt <- c(list(catt.lcs, catt.psid), 
              catt.top5_psid, 
              list(catt.psid.trim))

all_catt_eval <- eval_catt(all_catt, all_plot_titles)
datatable(all_catt_eval, caption = "CATT Summary Statistics",
          options = list(scrollX = TRUE, paging = FALSE, pageLength = -1, searching = FALSE))
```

With LCS-PSID1, CATT estimates span from $-3,149.81 to $2,395.66, contrasting with the CATT estimated from experimental data which ranges from $-478.45 to $2,895.23, with a mean CATT estimate of $886.31. 

In contract, across the LCS-PSID1-based subsamples, the ranges of CATT estimates are relatively similar. Importantly, the mean CATT estimates remain positive in all cases and for the `card` subsample as well as the trimmed plus-sample the mean CATT values are notably reduced.
```{r, message=FALSE, warning=FALSE}
save_main_catt_panels(
  catt_refs = list(catt.lcs),
  catt_comps = list(catt.psid),
  ylabels = c("CATT (PSID1)"),
  prefix = "lcs_catt_main_panels",
  main_titles = c("(B) LCS-PSID1")
)

save_catt_panels(
  exp_catt = catt.lcs,
  catt_list  = catt.top5_psid,
  plot_titles = paste0("(", LETTERS[3:7], ") Top PSID1: ", top5_methods.psid),
  prefix = "lcs_catt_top5_psid"
)

save_plus_catt_panels(
  catt1_list = list(catt.lcs.psid),
  catt2_list = list(catt.psid.trim),
  ylabels = c("CATT (PSID1-PLUS-Trimmed)"),
  prefix = "lcs_catt_plus_panels",
  main_titles = c("(H) Trimmed LCS-PSID1-PLUS")
)
```

### Quantile treatment effect on the treated (QTET)
```{r, message=FALSE, warning=FALSE}
qte.lcs <- est_qte(Y, treat, covar, data = lcs, cores = 4)
qte.lcs_psid <- est_qte(Y, treat, covar, data = lcs_psid)
qte.top5_psid <- lapply(top5_datasets.psid, function(d) est_qte(Y, treat, covar, data = d))
```

```{r, message=FALSE, warning=FALSE}
qte.lcs.psid <- est_qte(Y, treat, NULL, data = lcs_trim_psid)
qte.lcs_psid.trim <- est_qte(Y, treat, covar, data = lcs_psid_trim)
```

```{r, message=FALSE, warning=FALSE}
qte.lcs0 <- est_qte(Y, treat, NULL, data = lcs)
qte.lcs_psid0 <- est_qte(Y, treat, NULL, data = lcs_psid)
qte.top5_psid0 <- lapply(top5_datasets.psid, function(d) est_qte(Y, treat, NULL, data = d))
```

```{r, message=FALSE, warning=FALSE}
qte.lcs_psid.trim0 <- est_qte(Y, treat, NULL, data = lcs_psid_trim)
```

```{r, message=FALSE, warning=FALSE, out.width='100%', fig.asp=1, fig.cap="FIGURED13. SubfigureB:LCS-PSID1.  SubfigureC-G:Top-LCS-PSID1. SubfigureH:LCS-PSID1-PLUS. QTET Estimates using LCS Data: Experimental vs. Nonexperimental"}
par(mfrow = c(2,2))
par(cex.main = 0.9)
ylim = c(-25000, 15000)
# PSID1
plot_qte(qte.lcs_psid, qte.lcs_psid0, qte.lcs, main = "(B) LCS-PSID1", ylim)
legend("bottomleft", legend = c("Experimental", "Unadjusted", "Adjusted"), 
       lty = 1, pch = c(16, 17, 16), col = c(4, 2, 1), bty = "n")

# PSID1 top methods
plot_qte_top(qte.top5_psid, qte.top5_psid0, qte.lcs, all_plot_titles, main_start = 3)

# PSID1-PLUS trimmed
plot_qte(qte.lcs_psid.trim, qte.lcs_psid.trim0, qte.lcs.psid, main = "(H) LCS-PSID1-PLUS (Trimmed)", ylim)
legend("bottomleft", legend = c("Experimental", "Unadjusted", "Adjusted"), 
    lty = 1, pch = c(16, 17, 16), col = c(4, 2, 1), bty = "n")
```

These figures present QTET estimates obtained from LCS-Experimental sample and several observational samples. The QTETs estimated from both the original and trimmed LCS-PSID1 samples (B and C), as well as from the top-ranked subsamples (E through H), align comparatively close with the true QTET. However, the QTETs from subsample (F) exhibit a stronger bias, suggesting greater estimation uncertainty.
```{r, message=FALSE, warning=FALSE}
# list results
plots_lcs <- list(
  list(mod = qte.lcs_psid, mod0 = qte.lcs_psid0, bm = qte.lcs, 
       main = "(B) LCS-PSID1"),
  list(mod = qte.lcs_psid.trim, mod0 = qte.lcs_psid.trim0, bm = qte.lcs.psid, 
       main = "(H) LCS-PSID1-PLUS (Trimmed)")
)

# save results
save_qtet(plots_lcs, prefix = "lcs")
save_qte_top(qte.top5_psid, qte.top5_psid0, qte.lcs, all_plot_titles, 
             main_start = 13, prefix = "lcs_top")
```

### Assessing outcome weights (OW)
```{r, warning=FALSE, message=FALSE}
# list all datasets
all_datasets <- c(list(lcs, lcs_psid), 
                  top5_datasets.psid, 
                  list(lcs_trim_psid))
```

```{r, warning=FALSE, message=FALSE}
# estimate ATT 
res_att <- get_res_att(all_datasets, Y, treat, covar)
# extract outcome weights
ow_att <- derive_ow(res_att)
```

```{r,  message=FALSE, warning=FALSE, out.width='100%', fig.asp=1, fig.cap="FIGURED14. Outcome Weights using LCS Data"}
par(mfrow = c(2,2))
par(cex.main = 0.9)
# plot outcome weights distribution
plot_ow(ow_att, all_plot_titles) 
```

```{r, warning=FALSE, message=FALSE}
# evaluate results
res_ow <- eval_ow(ow_att, all_datasets, all_plot_titles, treat, "AIPW-ATT")
datatable(res_ow, caption = "Outcome Weights for Treated and Untreated",
          options = list(scrollX = TRUE, paging = FALSE, pageLength = -1, searching = FALSE))
```

Consistent with the preceding sections, the evaluation shows that, across each sample, the estimated outcome weights sum to one within the treated group and to minus one within the untreated group, yielding an overall total of zero.
```{r, message=FALSE, warning=FALSE}
# save results
save_ow(ow_att, all_plot_titles, prefix = "lcs")
```

## Validation through placebo analyses
```{r, warning=FALSE, message=FALSE}
# define variables
Y <- "nchildren75"
treat <- "treat"
covar <- c("age", "educ", "nodegree", "married", "black", "hisp", "re75", "u75")
```

```{r, warning=FALSE, message=FALSE}
# estimate placebo ATT on original and observational dataset
out1_pl <- estimate_all(lcs, Y, "treat", covar)
out2_pl <- estimate_all(lcs_psid, Y, "treat", covar)
```

```{r, message=FALSE, warning=FALSE}
# estimate placebo ATT on top ranked datasets
out.psid_pl <- lapply(top5_datasets.psid, function(d) estimate_all(d, Y, "treat", covar))
out3_pl <- out.psid_pl[[1]]
out4_pl <- out.psid_pl[[2]]
out5_pl <- out.psid_pl[[3]]
out6_pl <- out.psid_pl[[4]]
out7_pl <- out.psid_pl[[5]]
```

```{r, warning=FALSE, message=FALSE}
# estimate placebo ATT on plus datasets
load("data/trimmed.RData")
out8_pl <- estimate_all(lcs_trim_psid, Y, "treat", covar)
out9_pl <- estimate_all(lcs_psid_trim, Y, "treat", covar)
```

```{r, message=FALSE, warning=FALSE, out.width='100%', fig.asp=1, fig.cap="FIGURED15. SubfigureA:LCS-Experimental. SubfigureB:LCS-PSID1. SubfigureC-G:Top-LCS-PSID1. Placebo Test: Number of Children in 1975 as the Outcome"}
par(mfrow = c(4, 1), mar = c(4, 4, 2, 1))

# experimental benchmarks
band.exp_pl <- out1_pl[1, 3:4]
est.exp_pl <- out1_pl[1, 1]

# plot placebo results
plot_coef(out1_pl,  band = band.exp_pl, line = est.exp_pl, 
          ylim = c(-1.5, 1), main = "(A) LCS-Experimental")

plot_coef(out2_pl,  band = band.exp_pl, line = est.exp_pl,
          ylim = c(-1.5, 1), main = "(B) LCS-PSID1")

for (i in seq_along(out.psid_pl)) {
  this_title <- paste0("(", LETTERS[i+2], ") Top PSID1: ", top5_methods.psid[i])
  plot_coef(out.psid_pl[[i]], band = band.exp_pl, line = est.exp_pl,
            ylim = c(-1.5, 1), main = this_title)
}
```

```{r, message=FALSE, warning=FALSE, out.width='100%', fig.asp=1, fig.cap="FIGUREA15. SubfigureH:LCS-PSID1-PLUS. Placebo Test: Number of Children in 1975 as the Outcome"}
par(mfrow = c(4, 1))

# nonexperimtenal benchmarks
band.psid_plus_pl <- out8_pl[1, 3:4]
est.psid_plus_pl <- out8_pl[1, 1]

# plot results
plot_coef(out9_pl, band = band.psid_plus_pl, line = est.psid_plus_pl, 
          ylim = c(-1.5, 1), main = "(H) LCS-PSID1-PLUS (Trimmed)")
```

```{r, message=FALSE, warning=FALSE}
# save results
save_att_panels(
  out_list = list(out1_pl, out2_pl),
  plot_titles = c("(A) LCS-Experimental", "(B) LCS-CPS1"),
  band_list = list(band.exp_pl, band.exp_pl),
  est_list  = list(est.exp_pl, est.exp_pl),
  prefix = "lcs_pl_est_exp"
)

save_att_panels(
  out_list = out.psid_pl,
  plot_titles = paste0("(", LETTERS[3:7], ") Top PSID1: ", top5_methods.psid),
  band_list = replicate(length(out.psid_pl), band.exp_pl, simplify = FALSE),
  est_list  = replicate(length(out.psid_pl), est.exp_pl, simplify = FALSE),
  prefix = "lcs_pl_est_top_psid"
)

save_att_panels(
  out_list = list(out9_pl),
  plot_titles = c("(H) LCS-PSID1-PLUS (Trimmed)"),
  band_list = list(band.psid_plus_pl),
  est_list  = list(est.psid_plus_pl),
  prefix = "lcs_pl_est_plus",
  ylim = c(-12000, 2000)
)
```

```{r, message=FALSE, warning=FALSE}
# print placebo results
all_outs.pl <- c(list(out1_pl, out2_pl), 
                 out.psid_pl, 
                 list(out9_pl))

result_mat_pl <- create_matrix_results(all_outs.pl, all_plot_titles)

datatable(result_mat_pl, caption = "Placebo ATT Estimates and SEs",
          options = list(scrollX = TRUE, paging = FALSE, pageLength = -1, searching = FALSE))
```

The placebo analysis shows that the experimental benchmark is close to zero and statistically insignificant, while all estimators applied to the observational datasets produce comparable results.
```{r, message=FALSE, warning=FALSE}
# save results 
save_csv(result_mat_pl, "lcs_att_estimates_pl")
```

## Validation through sensitivity analyses
```{r, warning=FALSE, message=FALSE}
# define variables
Y <- "re79"
treat <- "treat"
# redefine covariates
covar <- c("age", "educ", "nodegree", "married", "black", "hisp", "re75", "u75")
bm <- c("re75")
```

```{r, warning=FALSE, message=FALSE}
# check for valid datasets 
filtered_datasets_sens <- check_filter_datasets(all_datasets, Y, treat, covar, bm)
```

```{r, message=FALSE, warning=FALSE, out.width='100%', fig.asp=1, fig.cap="FIGURED16. Sensitivity Analyses LCS"}
par(mfrow = c(2,2))
par(cex.main = 0.8)
# loop over valid datasets and assign index
for (i in seq_along(filtered_datasets_sens)) {
    idx <- which(sapply(all_datasets, identical, filtered_datasets_sens[[i]]))
    sens_ana(filtered_datasets_sens[[i]], Y, treat, covar, bm, kd = 1:3)
    title(main = all_plot_titles[idx]) 
}
```

```{r, message=FALSE, warning=FALSE}
# save results
save_sensitivity_plots(filtered_datasets_sens, Y, treat, covar, bm, all_plot_titles, "lcs")
```

The sensitivity analysis shows that treatment effect estimates in LCS-Experimental (A) are robust to unmeasured confounding, as expected. Observational samples instead show varying degrees of sensitivity, with the full observational sample (B) being more sensitive than the trimmed version (H). The top-ranked PSID1 subsamples (C-G) show that despite employing advanced criteria to improve balance and overlap, treatment effect estimates can exhibit increasing bias under plausible stronger confounding scenarios based on the reference confounder strength. 

## Summary
After reexamining the LaLonde-Calónico-Smith (LCS) data, the results confirm that, as with the NSW and LDW datasets, overlap between treated and control groups is generally stronger in the experimental sample than in the observational (PSID-1) controls. Augmenting the sample with experimental controls improves overlap but does not consistently resolve covariate imbalance.

The findings for the LCS sample closely mirror those from the LDW and NSW analyses: while certain methods can bring effect estimates closer to experimental benchmarks, substantial estimator-dependent variability and sensitivity to sample construction persist. Placebo and sensitivity analyses again show that unconfoundedness is difficult to verify, and that treatment effect estimates from observational data remain fragile. This underscores the ongoing challenge of obtaining reliable causal estimates for the LCS data.


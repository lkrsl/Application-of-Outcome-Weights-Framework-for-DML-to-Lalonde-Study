[["index.html", "Application of the Outcome Weights Framework for Double Machine Learning to the Lalonde Study Preface", " Application of the Outcome Weights Framework for Double Machine Learning to the Lalonde Study Laura Kreisel 2025-11-15 Preface This book replicates the LaLonde study by Imbens and Xu (2024) and extends it by comparing a full with a reduced covariate model to mitigate potential confounding. It evaluates various methods to improve overlap and covariate balance for robust treatment effect estimation and applies the outcome weights framework by Knaus and Pfleiderer (2024) to assess another estimator and analyse the distributional properties of outcome weights. The analysis draws on the original LaLonde dataset as well as the LaLonde–Dehejia–Wahba (LDW) and LaLonde–Calónico–Smith (LCS) datasets. Section 1 introduces required packages and wrapper functions used throughout the analysis. Section 2 replicates and extends the full covariate model from Imbens and Xu (2024) using the LaLonde-Dehejia-Wahba (LDW) dataset. Section 3 applies a reduced covariate set to the same LDW dataset. Section 4 analyzes the original LaLonde dataset following similar methods and section 5 explores the LaLonde-Calónico-Smith (LCS) dataset, focusing on female samples. References Imbens, Guido W., and Yiqing Xu. 2024. “LaLonde (1986) After Nearly Four Decades: Lessons Learned.” Knaus, Michael C., and Henri Pfleiderer. 2024. “Outcome Weights.” "],["lalonde-dehejia-wahba-ldw-data.html", "Chapter 1 LaLonde-Dehejia-Wahba (LDW) Data 1.1 Set up 1.2 Model A 1.3 Assessing overlap and covariate balance 1.4 Improving overlap 1.5 Assessing methods 1.6 Identifying best methods 1.7 Estimating", " Chapter 1 LaLonde-Dehejia-Wahba (LDW) Data LaLonde (1986) evaluated the effect of the National Supported Work Demonstration (NSW) program on both female and male participants. While the female participants were drawn from the Aid to Families with Dependent Children (AFDC) program, the male participants were drawn from three other groups: former drug addicts, ex-criminal offenders, and high-school dropouts. LaLonde relied on two main data sources: (1) CPS-SSA-1, based on Westat’s Matched Current Population Survey–Social Security Administration File for individuals under 55 matching specific criteria; (2) PSID-1, based on Panel Study of Income Dynamics for household heads under 55 from specific years who were not retired in 1975, adjusted for factors like employment status and poverty level, resulting in four additional comparison groups. Dehejia and Wahba (1999) constructed a subset of LaLonde’s original data, retaining 62% of observations and restricting the focus to male participants based on their 1974 earnings. As the dataset was formed entirely on pretreatment information like employment records or month of assignment, treatment allocation was effectively independent of all pre-treatment variables. Thus, they concluded that this subset, known as the LaLonde-Dehejia-Wahba (LDW) data, constitutes a valid experimental sample. The analysis in section 2 and 3 builds on the LDW data and considers in total three samples: (1) LDW-Experimental, consisting of 185 treated individuals and 280 controls from the experimental data; (2) LDW-CPS1, which pairs the same treated sample with 15,992 controls from CPS-SSA-1; (3) LDW-PSID1, featuring the same treated sample with 2,490 controls from PSID-1; In section 4, the analysis applies the same set of statistical tools to analyze a fourth sample as an additional demonstration: (4) LaLonde male samples (1986). In the last section, the analysis applies a reduced set of statistical tools to analyze a fifth sample again as an additional demonstration: (5) LaLonde female samples (2017). This section (2) covers model A, which includes the outcome variable 1978 earnings (re78) and adjusts for a set of covariates: age, education, race (black, hispanic), marital status, high school dropouts, 1974 and 1975 earnings (re74, re75), and unemployment status in 1974 and 1975 (u74, u75). The model is defined by a regression formula for treatment assignment using these covariates. To improve covariate balance and overlap between treated and control groups, various methods are applied and are structured into five parts (matching, weighting, truncation, trimming and integrated methods). From these methods, the five best methods are determined based on a score defined by absolute standardized mean differences (SMD) and the effective sample size (ESS). The corresponding datasets are used to estimate the average treatment effect on the treated (ATT). Notably, the estimation incorporates the recently introduced augmented inverse probability weighting (AIPW) estimator, implemented via the OutcomeWeights R package. Subsequently, alternative estimands are considered, including the conditional average treatment effect for the treated (CATT) and the quantile treatment effect on the treated (QTET). After estimating these effects, outcome weights are analyzed to identify potential patterns in the contribution of individual observations to the ATT. Placebo tests are then conducted using 1975 earnings (re75) as an outcome to assess potential biases and the validity of unconfoundedness assumptions. Finally, sensitivity analyses are performed to evaluate the robustness of treatment effect estimates to violations of these assumptions. 1.1 Set up 1.1.1 Source functions and load data source(&quot;https://github.com/xuyiqing/lalonde/blob/main/tutorial/functions.R?raw=TRUE&quot;) source(&quot;tutorial/functions.R&quot;) #source(&quot;C:/Users/lkreisel/workspace/uni-projects/Application-of-Outcome-Weights-Framework-for-DML-to-Lalonde-Study/tutorial/functions.R&quot;) # source functions (skip remote copy when offline) # remote_url &lt;- &quot;https://raw.githubusercontent.com/xuyiqing/lalonde/main/tutorial/functions.R&quot; # tryCatch( # source(remote_url, local = FALSE), # error = function(e) message(&quot;Skipping remote helper script: &quot;, conditionMessage(e)) # ) # source(&quot;tutorial/functions.R&quot;) # load data load(&quot;data/lalonde.RData&quot;) # set seed set.seed(42) 1.1.2 Inspect data We begin the analysis with an overview of each dataset, where the dataset name, number of observations (rows), number of treated and control units, number of variables (columns), and variable names are reviewed. # collect datasets in a list data &lt;- list(lalonde = lalonde, ldw_tr = ldw_tr, ldw_co = ldw_co, ldw_cps = ldw_cps, ldw_psid = ldw_psid) # inspect key metrics of each dataset summary_stats &lt;- inspect_data(data) datatable(summary_stats, caption = &quot;Summary Statistics&quot;, options = list(scrollX = TRUE, paging = FALSE, pageLength = -1, searching = FALSE)) 1.1.3 Load and preprocess data Next, we augment the control groups in LDW-CPS1 and LDW-PSID1 by merging them with the experimental controls from LDW-Experimental. This approach follows the methodology laid out by Imbens and Xu (2024). These expanded datasets are used solely for comparative purposes, while all primary analyses rely on the original LDW‑CPS1 and LDW‑PSID1 data. # assigns 1 to the experimental controls ldw_co$treat &lt;- 1 # merge experimental data with CPS1 data ldw_cps_plus &lt;- rbind.data.frame( ldw_co, # experimental controls ldw_cps # CPS1 data ) # merge experimental data with PSID1 data ldw_psid_plus &lt;- rbind.data.frame( ldw_co, # experimental controls ldw_psid # PSID1 data ) datasets &lt;- list(ldw_cps_plus = ldw_cps_plus, ldw_psid_plus = ldw_psid_plus) # inspect each dataset summary_stats_plus &lt;- inspect_data(datasets) datatable(summary_stats_plus, caption = &quot;Summary Statistics&quot;, options = list(scrollX = TRUE, paging = FALSE, pageLength = -1, searching = FALSE)) 1.2 Model A Finally, we define Model A as the baseline specification underlying the analysis. # define variables Y &lt;- &quot;re78&quot; treat &lt;- &quot;treat&quot; covar &lt;- c(&quot;age&quot;, &quot;education&quot;, &quot;black&quot;, &quot;hispanic&quot;, &quot;married&quot;, &quot;nodegree&quot;, &quot;re74&quot;, &quot;re75&quot;, &quot;u74&quot;, &quot;u75&quot;) #re74 included 1.3 Assessing overlap and covariate balance 1.3.1 Overlap To identify the average causal effect under unconfoundedness (that asserts that the treatment assignment is independent of the potential outcomes), it must be ensured that one can estimate the average effect at every value for the covariates. Thus, overlaps between the treated and untreated units (meaning that for every combination of covariates, there are both treated and untreated units in the dataset) are required. To assess overlap in the propensity scores and visualize the results using histograms of their log-odds, we use the assess_overlap() function of Imbens and Xu (2024). In a properly balanced experimental design, the distributions of the treatment group (red) and the control group (gray) would show considerable coverage. ldw.ps &lt;- assess_overlap(data = ldw, treat = treat, cov = covar) ## -1.310867 0.7158619 Figure 1.1: FIGUREA1. SubfigureA:LDW. SubfigureB:LDW-CPS1. SubfigureC:LDW-PSID1. ldw_cps.ps &lt;- assess_overlap(data = ldw_cps, treat = treat, cov = covar) ## -16.1181 1.787343 Figure 1.2: FIGUREA1. SubfigureA:LDW. SubfigureB:LDW-CPS1. SubfigureC:LDW-PSID1. ldw_psid.ps &lt;- assess_overlap(data = ldw_psid, treat = treat, cov = covar) ## -16.1181 3.752723 Figure 1.3: FIGUREA1. SubfigureA:LDW. SubfigureB:LDW-CPS1. SubfigureC:LDW-PSID1. As anticipated, LDW-Experimental exhibits an almost perfect overlap. In contrast, the observational datasets LDW-CPS1 and LDW-PSID1 show weak overlap. Notably, many treated units have propensity scores outside the range of the controls, while a large share of control units have propensity scores concentrated at very low log-odds. Next, the overlap of the expanded observational datasets is examined. ldw_cps_plus.ps &lt;- assess_overlap(data = ldw_cps_plus, treat = treat, cov = covar) ## -16.1181 3.63151 Figure 1.4: FIGUREA1. SubfigureD:LDW-CPS1-PLUS. SubfigureE:LDW-PSID1-PLUS. ldw_psid_plus.ps &lt;- assess_overlap(data = ldw_psid_plus, treat = treat, cov = covar) ## -16.1181 7.271394 Figure 1.5: FIGUREA1. SubfigureD:LDW-CPS1-PLUS. SubfigureE:LDW-PSID1-PLUS. As expected, the datasets LDW-CPS1-PLUS and LDW-PSID1-PLUS show an improved overlap compared to their non-plus states. For the following analysis, we set up a model formula. # set model formula model &lt;- as.formula(paste(treat, &quot;~&quot;, paste(covar, collapse = &quot; + &quot;))) 1.3.2 Covariate balance To make treatment and control groups more comparable, thus mimicking a randomized experiment, initial covariate balance is assessed to determine the degree to which treatment and control groups differ on observed characteristics. Therefore, we employ visual summaries using love.plot() by Imbens and Xu (2024), which depicts standardized mean differences across covariates before and after adjustment. # plot balance love.plot(ldw, ldw_cps, treat, covar = covar, title = &quot;LDW-CPS1&quot;) Figure 1.6: FIGUREA2. SubfigureA:LDW-CPS1. SubfigureB:LDW-CPS1-PLUS. SubfigureC:LDW-PSID1. SubfigureD:LDW-PSID1-PLUS. love.plot(ldw, ldw_psid, treat, covar = covar, title = &quot;LDW-PSID1&quot;) Figure 1.7: FIGUREA2. SubfigureA:LDW-CPS1. SubfigureB:LDW-CPS1-PLUS. SubfigureC:LDW-PSID1. SubfigureD:LDW-PSID1-PLUS. love.plot(ldw, ldw_cps_plus, treat, covar = covar, title = &quot;LDW-CPS1-PLUS&quot;) Figure 1.8: FIGUREA2. SubfigureA:LDW-CPS1. SubfigureB:LDW-CPS1-PLUS. SubfigureC:LDW-PSID1. SubfigureD:LDW-PSID1-PLUS. love.plot(ldw, ldw_psid_plus, treat, covar = covar, title = &quot;LDW-PSID1-PLUS&quot;) Figure 1.9: FIGUREA2. SubfigureA:LDW-CPS1. SubfigureB:LDW-CPS1-PLUS. SubfigureC:LDW-PSID1. SubfigureD:LDW-PSID1-PLUS. Neither LDW-CPS1-PLUS nor LDW-PSID1-PLUS shows consistently improved covariate balance compared to their non-plus counterparts based on raw standardized mean differences. Although some specific covariates improve slightly, most show increased imbalance. For the subsequent analysis aimed at enhancing covariate balance and overlap, only the two datasets LDW-CPS1 and LDW-PSID1 are used. The LDW-Experimental dataset is excluded from these steps, as randomization already ensures adequate covariate balance and overlap. 1.4 Improving overlap 1.4.1 Single methods 1.4.1.1 Trimming The purpose of trimming is to remove units whose propensity scores are too dissimilar from the opposite group, thereby improving covariate balance between treated and control groups. Below, we employ several trimming methods in line with the approaches proposed by Stürmer et al. (2021) and Imbens and Xu (2024). Propensity score threshold trimming # apply trimming with threshold 0.9 ldw_cps.ps_trim &lt;- ps_trim(ldw_cps.ps, threshold = 0.9) ldw_psid.ps_trim &lt;- ps_trim(ldw_psid.ps, threshold = 0.9) # re-estimate propensity scores on trimmed data ldw_cps.ps_trim &lt;- ps_estimate(data = ldw_cps.ps_trim, treat = treat, cov = covar) ldw_psid.ps_trim &lt;- ps_estimate(data = ldw_psid.ps_trim, treat = treat, cov = covar) Common range trimming # trim observations outside the common support region of propensity scores ldw_cps.ps_common &lt;- common_range_trim(ldw_cps.ps) ldw_psid.ps_common &lt;- common_range_trim(ldw_psid.ps) # re-estimate propensity scores on trimmed data ldw_cps.ps_common &lt;- ps_estimate(data = ldw_cps.ps_common, treat = treat, cov = covar) ldw_psid.ps_common &lt;- ps_estimate(data = ldw_psid.ps_common, treat = treat, cov = covar) Crump trimming # trim observations with propensity scores outside [0.1, 0.9] interval ldw_cps.ps_crump &lt;- crump_trim(ldw_cps.ps, lower = 0.1, upper = 0.9) ldw_psid.ps_crump &lt;- crump_trim(ldw_psid.ps, lower = 0.1, upper = 0.9) # re-estimate propensity scores on trimmed data ldw_cps.ps_crump &lt;- ps_estimate(data = ldw_cps.ps_crump, treat = treat, cov = covar) ldw_psid.ps_crump &lt;- ps_estimate(data = ldw_psid.ps_crump, treat = treat, cov = covar) Stuermer trimming # trim observations based on propensity score quantiles separately for treated and control ldw_cps.ps_stuermer &lt;- stuermer_trim(ldw_cps.ps) ldw_psid.ps_stuermer &lt;- stuermer_trim(ldw_psid.ps) # re-estimate propensity scores on trimmed data ldw_cps.ps_stuermer &lt;- ps_estimate(data = ldw_cps.ps_stuermer, treat = treat, cov = covar) ldw_psid.ps_stuermer &lt;- ps_estimate(data = ldw_psid.ps_stuermer, treat = treat, cov = covar) Walker trimming # trim observations based on preference scores that adjust for treatment prevalence using logit transformations ldw_cps.ps_walker &lt;- walker_trim(ldw_cps.ps) ldw_psid.ps_walker &lt;- walker_trim(ldw_psid.ps) # re-estimate propensity scores on trimmed data ldw_cps.ps_walker &lt;- ps_estimate(data = ldw_cps.ps_walker, treat = treat, cov = covar) ldw_psid.ps_walker &lt;- ps_estimate(data = ldw_psid.ps_walker, treat = treat, cov = covar) 1.4.2 Integrated methods 1.4.2.1 Trimming and matching The purpose of matching is to create comparable treated and control groups by pairing units with similar covariate profiles, thereby reducing covariate imbalance and confounding bias. We apply several matching methods as outlined by Greifer (2025) in the following. For comparison, combinations of trimming and matching methods are applied in line with the tutorial by Imbens and Xu (2024), before being applied to the initial datasets. 1.4.2.1.1 Extended datasets (similar to tutorial by Imbens and Xu (2024)) ldw_cps_trim &lt;- ps_trim(ldw_cps_plus.ps, threshold = 0.9) ldw_psid_trim &lt;- ps_trim(ldw_psid_plus.ps, threshold = 0.8) # excluding the experimental controls ldw_cps.trim_match &lt;- subset(ldw_cps_trim, sample %in% c(1,3) &amp; ps_assoverlap) ldw_psid.trim_match &lt;- subset(ldw_psid_trim, sample %in% c(1,4) &amp; ps_assoverlap) # re-estimate propensity scores and employ 1:1 matching ldw_cps.trim_match &lt;- psmatch(data = ldw_cps.trim_match, Y = &quot;re78&quot;, treat = &quot;treat&quot;, cov = covar) ldw_psid.trim_match &lt;- psmatch(data = ldw_psid.trim_match, Y = &quot;re78&quot;, treat = &quot;treat&quot;, cov = covar) # further subset data and re-assign treat variable ldw_trim_cps &lt;- subset(ldw_cps_trim, sample %in% c(1,2) &amp; ps_assoverlap &lt;= 0.9) ldw_trim_cps$treat[which(ldw_trim_cps$sample == 2)] &lt;- 0 ldw_trim_psid &lt;- subset(ldw_psid_trim, sample %in% c(1,2) &amp; ps_assoverlap &lt;= 0.8) ldw_trim_psid$treat[which(ldw_trim_psid$sample == 2)] &lt;- 0 all_trim.cps &lt;- list( ps_threshold = ldw_cps.ps_trim, common_range = ldw_cps.ps_common, stuermer = ldw_cps.ps_stuermer, walker = ldw_cps.ps_walker, crump = ldw_cps.ps_crump) all_trim.psid &lt;- list( ps_threshold = ldw_psid.ps_trim, common_range = ldw_psid.ps_common, stuermer = ldw_psid.ps_stuermer, walker = ldw_psid.ps_walker, crump = ldw_psid.ps_crump) 1.4.2.1.2 Initial datasets 1.4.2.1.2.1 Distance matching 1:1 Nearest neighbor matching with 1) propensity threshold 2) common range 3) stuermer 4) walker 5) crump trimming # perform nearest neighbor matching with k=1, logistic propensity score and replacement nn_trim_comb.cps &lt;- attach_matchit(model, data_list = all_trim.cps, method = &quot;nearest&quot;, distance = &quot;glm&quot;, link = &quot;logit&quot;, replace = TRUE) nn_trim_comb.psid &lt;- attach_matchit(model, data_list = all_trim.psid, method = &quot;nearest&quot;, distance = &quot;glm&quot;, link = &quot;logit&quot;, replace = TRUE) names(match.data(nn_trim_comb.cps[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; names(match.data(nn_trim_comb.psid[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; bal&lt;- bal.tab(nn_trim_comb.cps[[1]], data = all_trim.cps[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] 0.0002916864 -0.0113320563 -0.0430141872 -0.0108108108 -0.0054054054 ## [6] -0.0108108108 0.0108108108 -0.1134446902 -0.0767658632 0.0108108108 ## [11] 0.0432432432 bal&lt;- bal.tab(nn_trim_comb.psid[[1]], data = all_trim.psid[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] -0.002286931 0.350471405 -0.246647484 -0.006211180 0.031055901 ## [6] 0.086956522 0.105590062 -0.169851039 -0.285231720 0.062111801 ## [11] 0.136645963 k:1 matching (k=2) with 1) propensity threshold 2) common range 3) stuermer 4) walker 5) crump trimming # perform nearest neighbor matching with k=2, logistic propensity score and replacement k&lt;-2 k2_trim_comb.cps &lt;- attach_matchit(model, data_list = all_trim.cps, method = &quot;nearest&quot;, distance = &quot;glm&quot;, link = &quot;logit&quot;, ratio = k, replace = TRUE) k2_trim_comb.psid &lt;- attach_matchit(model, data_list = all_trim.psid, method = &quot;nearest&quot;, distance = &quot;glm&quot;, link = &quot;logit&quot;, ratio = k, replace = TRUE) names(match.data(k2_trim_comb.cps[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; names(match.data(k2_trim_comb.psid[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; bal&lt;-bal.tab(k2_trim_comb.cps[[1]], data = all_trim.cps[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] -0.0004841974 0.0207754365 -0.1196332081 -0.0135135135 0.0054054054 ## [6] 0.0216216216 0.0540540541 -0.0726208913 -0.0417687276 0.0108108108 ## [11] 0.0378378378 bal&lt;-bal.tab(k2_trim_comb.psid[[1]], data = all_trim.psid[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] -0.003622634 0.286828588 -0.147386911 -0.018633540 0.018633540 ## [6] 0.074534161 0.086956522 -0.169816889 -0.144049001 0.077639752 ## [11] 0.074534161 k:1 matching (k=3) with 1) propensity threshold 2) common range 3) stuermer 4) walker 5) crump trimming # perform nearest neighbor matching with k=3, logistic propensity score and replacement k&lt;-3 k3_trim_comb.cps &lt;- attach_matchit(model, data_list = all_trim.cps, method = &quot;nearest&quot;, distance = &quot;glm&quot;, link = &quot;logit&quot;, ratio = k, replace = TRUE) k3_trim_comb.psid &lt;- attach_matchit(model, data_list = all_trim.psid, method = &quot;nearest&quot;, distance = &quot;glm&quot;, link = &quot;logit&quot;, ratio = k, replace = TRUE) names(match.data(k3_trim_comb.cps[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; names(match.data(k3_trim_comb.psid[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; bal&lt;-bal.tab(k3_trim_comb.cps[[1]], data = all_trim.cps[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] -0.0003286797 0.0994702718 -0.1254580459 -0.0144144144 0.0090090090 ## [6] 0.0288288288 0.0612612613 -0.0514340070 -0.0114861859 0.0216216216 ## [11] 0.0468468468 bal&lt;-bal.tab(k3_trim_comb.psid[[1]], data = all_trim.psid[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] -0.005770912 0.280144639 -0.061160555 -0.033126294 0.026915114 ## [6] 0.078674948 0.053830228 -0.164892321 -0.116202224 0.091097308 ## [11] 0.055900621 Caliper matching with 1) propensity threshold 2) common range 3) stuermer 4) walker 5) crump trimming # perform nearest neighbor matching with a caliper of 0.1 on the logistic propensity score caliper_trim_comb.cps &lt;- attach_matchit(model, data_list = all_trim.cps, method = &quot;nearest&quot;, distance = &quot;glm&quot;, link = &quot;logit&quot;, caliper = 0.1, replace = TRUE) caliper_trim_comb.psid &lt;- attach_matchit(model,data_list = all_trim.psid, method = &quot;nearest&quot;, distance = &quot;glm&quot;, link = &quot;logit&quot;, caliper = 0.1, replace = TRUE) names(match.data(caliper_trim_comb.cps[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; names(match.data(caliper_trim_comb.psid[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; bal&lt;-bal.tab(caliper_trim_comb.cps[[1]], data = all_trim.cps[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] 0.0001395963 -0.0293423041 -0.0357213813 -0.0110497238 -0.0055248619 ## [6] -0.0110497238 0.0110497238 -0.1159517552 -0.0759374331 0.0110497238 ## [11] 0.0386740331 bal&lt;-bal.tab(caliper_trim_comb.psid[[1]], data = all_trim.psid[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] -0.0005330485 0.2981431493 -0.2050199578 -0.0364963504 0.0145985401 ## [6] 0.0656934307 0.0656934307 -0.1848659241 -0.1731015888 0.0948905109 ## [11] 0.0802919708 Common support restriction matching with 1) propensity threshold 2) common range 3) stuermer 4) walker 5) crump trimming # perform nearest neighbor matching with exclusion of units outside common support cs_trim_comb.cps &lt;- attach_matchit(model, data_list = all_trim.cps, method = &quot;nearest&quot;, distance = &quot;glm&quot;, link = &quot;logit&quot;, discard = &quot;both&quot;, reestimate = TRUE, replace = TRUE) cs_trim_comb.psid &lt;- attach_matchit(model,data_list = all_trim.psid, method = &quot;nearest&quot;, distance = &quot;glm&quot;, link = &quot;logit&quot;, discard = &quot;both&quot;, reestimate = TRUE, replace = TRUE) names(match.data(cs_trim_comb.cps[[1]], data = all_trim.cps[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; names(match.data(cs_trim_comb.psid[[1]], data = all_trim.psid[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; bal&lt;-bal.tab(cs_trim_comb.cps[[1]], data = all_trim.cps[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] -0.0001878909 -0.0687478081 -0.2285128694 -0.0216216216 0.0162162162 ## [6] 0.0324324324 0.1081081081 -0.0248358187 0.0332877981 0.0054054054 ## [11] 0.0378378378 bal&lt;-bal.tab(cs_trim_comb.psid[[1]], data = all_trim.psid[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] -0.002392401 0.428195761 -0.260525688 0.000000000 0.025316456 ## [6] 0.101265823 0.107594937 -0.185376674 -0.345199002 0.075949367 ## [11] 0.158227848 Mahalanobis distance matching (mahvars) with 1) propensity threshold 2) common range 3) stuermer 4) walker 5) crump trimming # perform nearest neighbor matching using mahalanobis distance mahvars_trim_comb.cps &lt;- attach_matchit(model, data_list = all_trim.cps, method = &quot;nearest&quot;, distance = &quot;mahalanobis&quot;, replace = FALSE) mahvars_trim_comb.psid &lt;- attach_matchit(model,data_list = all_trim.psid, method = &quot;nearest&quot;, distance = &quot;mahalanobis&quot;, replace = FALSE) names(match.data(mahvars_trim_comb.cps[[1]], data = all_trim.cps[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;weights&quot; ## [17] &quot;subclass&quot; names(match.data(mahvars_trim_comb.psid[[1]], data = all_trim.psid[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;weights&quot; ## [17] &quot;subclass&quot; bal&lt;-bal.tab(mahvars_trim_comb.cps[[1]], data = all_trim.cps[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] -0.16015973 -0.15861482 0.00000000 0.00000000 -0.09729730 0.08648649 ## [7] -0.09637309 -0.16710243 0.02702703 0.02702703 bal&lt;-bal.tab(mahvars_trim_comb.psid[[1]], data = all_trim.psid[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] -0.70878919 -0.12031585 0.21118012 0.00000000 -0.22981366 0.07453416 ## [7] -0.53871439 -1.11890793 0.13664596 0.13664596 Optimal pair matching with 1) propensity threshold 2) common range 3) stuermer 4) walker 5) crump trimming # perform optimal pair matching that minimizes total within-pair distance on propensity scores optimal_pair_trim_comb.cps &lt;- attach_matchit(model, data_list = all_trim.cps, method = &quot;optimal&quot;, distance = &quot;glm&quot;, link = &quot;logit&quot;) optimal_pair_trim_comb.psid &lt;- attach_matchit(model,data_list = all_trim.psid, method = &quot;optimal&quot;, distance = &quot;glm&quot;, link = &quot;logit&quot;) names(match.data(optimal_pair_trim_comb.cps[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; &quot;subclass&quot; names(match.data(optimal_pair_trim_comb.psid[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; &quot;subclass&quot; bal&lt;-bal.tab(optimal_pair_trim_comb.cps[[1]], data = all_trim.cps[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] 0.083293194 -0.151849554 -0.080651601 -0.005405405 0.005405405 ## [6] 0.000000000 0.075675676 -0.007883418 0.018281309 0.005405405 ## [11] 0.054054054 bal&lt;-bal.tab(optimal_pair_trim_comb.psid[[1]], data = all_trim.psid[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] 1.228568272 -0.430678791 0.003007896 0.086956522 0.000000000 ## [6] -0.267080745 0.043478261 -0.451694717 -0.411432783 0.279503106 ## [11] 0.167701863 Optimal full matching with 1) propensity threshold 2) common range 3) stuermer 4) walker 5) crump trimming # perform optimal full matching allowing sets with varying ratios of treated to controls and minimizing a global distance criterion optimal_full_trim_comb.cps &lt;- attach_matchit(model, data_list = all_trim.cps, method = &quot;full&quot;, distance = &quot;glm&quot;, link = &quot;logit&quot;) optimal_full_trim_comb.psid &lt;- attach_matchit(model,data_list = all_trim.psid, method = &quot;full&quot;, distance = &quot;glm&quot;, link = &quot;logit&quot;) names(match.data(optimal_full_trim_comb.cps[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; &quot;subclass&quot; names(match.data(optimal_full_trim_comb.psid[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; &quot;subclass&quot; bal&lt;-bal.tab(optimal_full_trim_comb.cps[[1]], data = all_trim.cps[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] 0.0004211628 -0.0008219281 -0.1251411402 -0.0083743533 0.0081288768 ## [6] 0.0203142168 0.0571349507 -0.0324191189 -0.0011120886 0.0065665683 ## [11] 0.0247902260 bal&lt;-bal.tab(optimal_full_trim_comb.psid[[1]], data = all_trim.psid[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] -0.002514483 0.300935391 -0.113841275 0.002619784 0.024647968 ## [6] 0.087701069 0.099496438 -0.164705334 -0.295531459 0.051797617 ## [11] 0.134374128 Generalized full matching with 1) propensity threshold 2) common range 3) stuermer 4) walker 5) crump trimming # perform generalized full matching using fast approximation and producing matched sets with flexible treated/control ratios general_full_trim_comb.cps &lt;- attach_matchit(model, data_list = all_trim.cps, method = &quot;quick&quot;, distance = &quot;glm&quot;, link = &quot;logit&quot;) general_full_trim_comb.psid &lt;- attach_matchit(model,data_list = all_trim.psid, method = &quot;quick&quot;, distance = &quot;glm&quot;, link = &quot;logit&quot;) names(match.data(general_full_trim_comb.cps[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; &quot;subclass&quot; names(match.data(general_full_trim_comb.psid[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; &quot;subclass&quot; bal&lt;-bal.tab(general_full_trim_comb.cps[[1]], data = all_trim.cps[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] 0.001068543 -0.024267937 -0.138828121 -0.011364898 0.005724407 ## [6] 0.002140818 0.049043884 -0.028461298 -0.020723582 0.002329407 ## [11] 0.025472237 bal&lt;-bal.tab(general_full_trim_comb.psid[[1]], data = all_trim.psid[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] -0.005692269 0.259796436 -0.200938810 0.001338319 0.024298636 ## [6] 0.088996249 0.118052748 -0.142382862 -0.218993310 0.048555876 ## [11] 0.112294368 Genetic matching with 1) propensity threshold 2) common range 3) stuermer 4) walker 5) crump trimming # perform genetic matching genetic_trim_comb.cps &lt;- attach_matchit(model, data_list = all_trim.cps, method = &quot;genetic&quot;, distance = &quot;glm&quot;, link = &quot;logit&quot;, replace = TRUE, pop.size = 100) genetic_trim_comb.psid &lt;- attach_matchit(model,data_list = all_trim.psid, method = &quot;genetic&quot;, distance = &quot;glm&quot;, link = &quot;logit&quot;, replace = TRUE, pop.size = 100) names(match.data(genetic_trim_comb.cps[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; names(match.data(genetic_trim_comb.psid[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; bal&lt;-bal.tab(genetic_trim_comb.cps[[1]], data = all_trim.cps[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] 7.559222e-03 1.586488e-02 -2.957225e-02 0.000000e+00 6.938894e-18 ## [6] 2.775558e-17 0.000000e+00 1.767089e-02 -1.571780e-02 0.000000e+00 ## [11] 0.000000e+00 bal&lt;-bal.tab(genetic_trim_comb.psid[[1]], data = all_trim.psid[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] 1.930063e-01 -1.891848e-01 1.022685e-01 -1.242236e-02 0.000000e+00 ## [6] 0.000000e+00 6.211180e-03 -1.621253e-02 -4.028517e-02 1.110223e-16 ## [11] -6.211180e-02 1.4.2.1.2.2 Stratum matching Exact matching (exact) # match units exactly by raw covariate profiles exact_trim_comb.cps &lt;- attach_matchit(model, data_list = all_trim.cps, method = &quot;exact&quot;) exact_trim_comb.psid &lt;- attach_matchit(model,data_list = all_trim.psid, method = &quot;exact&quot;) names(match.data(exact_trim_comb.cps[[1]], data = all_trim.cps[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;weights&quot; ## [17] &quot;subclass&quot; names(match.data(exact_trim_comb.psid[[1]], data = all_trim.psid[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;weights&quot; ## [17] &quot;subclass&quot; bal&lt;-bal.tab(exact_trim_comb.cps[[1]], data = all_trim.cps[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] 0.000000e+00 -1.776357e-15 0.000000e+00 0.000000e+00 0.000000e+00 ## [6] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 bal&lt;-bal.tab(exact_trim_comb.psid[[1]], data = all_trim.psid[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] 3.552714e-15 1.776357e-15 1.110223e-16 0.000000e+00 0.000000e+00 ## [6] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 Coarsened matching (cem) # match units exactly within coarse strata cem_trim_comb.cps &lt;- attach_matchit(model, data_list = all_trim.cps, method = &quot;cem&quot;) cem_trim_comb.psid &lt;- attach_matchit(model,data_list = all_trim.psid, method = &quot;cem&quot;) names(match.data(cem_trim_comb.cps[[1]], data = all_trim.cps[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;weights&quot; ## [17] &quot;subclass&quot; names(match.data(cem_trim_comb.psid[[1]], data = all_trim.psid[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;weights&quot; ## [17] &quot;subclass&quot; bal&lt;-bal.tab(cem_trim_comb.cps[[1]], data = all_trim.cps[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] 2.364587e-02 -1.915884e-03 -1.110223e-16 0.000000e+00 0.000000e+00 ## [6] 0.000000e+00 5.763641e-03 -2.422462e-02 0.000000e+00 0.000000e+00 bal&lt;-bal.tab(cem_trim_comb.psid[[1]], data = all_trim.psid[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] 2.082509e-02 -2.753699e-02 1.110223e-16 0.000000e+00 0.000000e+00 ## [6] 1.110223e-16 -1.832720e-01 -6.009392e-01 0.000000e+00 0.000000e+00 Subclassification # partition sample into fixed number of bins based on propensity score subcl_trim_comb.cps &lt;- attach_matchit(model, data_list = all_trim.cps, method = &quot;subclass&quot;, subclass = 5) subcl_trim_comb.psid &lt;- attach_matchit(model,data_list = all_trim.psid, method = &quot;subclass&quot;, subclass = 5) names(match.data(subcl_trim_comb.cps[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;distance&quot; ## [17] &quot;weights&quot; &quot;subclass&quot; names((subcl_trim_comb.psid[[1]])) ## [1] &quot;subclass&quot; &quot;weights&quot; &quot;X&quot; &quot;call&quot; &quot;info&quot; &quot;estimand&quot; ## [7] &quot;formula&quot; &quot;treat&quot; &quot;distance&quot; &quot;discarded&quot; &quot;q.cut&quot; &quot;model&quot; bal&lt;-bal.tab(subcl_trim_comb.cps[[1]], data = all_trim.cps[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] 0.04632267 -0.17493174 -0.08847568 0.06641796 0.01101620 -0.07205548 ## [7] 0.06220294 -0.35108177 -0.55099510 0.06250574 0.06368869 bal&lt;-bal.tab(subcl_trim_comb.psid[[1]], data = all_trim.psid[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] 0.11207335 0.17160382 -0.25541094 0.09115047 0.01257692 0.02829723 ## [7] 0.13773040 -0.70859203 -1.06239070 0.13840392 0.20242264 1.4.2.1.2.3 Pure subset selection Cardinality profile matching # select largest balanced subsample meeting covariate balance tolerances and a fixed ratio of controls to treated units card_trim_comb.cps &lt;- attach_matchit(model, data_list = all_trim.cps, method = &quot;cardinality&quot;, tols = 0.1, ratio = 1, time = 1200) card_trim_comb.psid &lt;- attach_matchit(model,data_list = all_trim.psid, method = &quot;cardinality&quot;, tols = 0.1, ratio = 1, time = 1200) names(match.data(card_trim_comb.cps[[1]], data = all_trim.cps[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;weights&quot; names(match.data(card_trim_comb.psid[[1]], data = all_trim.psid[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;weights&quot; bal&lt;-bal.tab(card_trim_comb.cps[[1]], data = all_trim.cps[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] -0.095189273 0.005376773 0.032432432 0.021621622 -0.037837838 ## [6] 0.043243243 -0.093022492 -0.099933959 0.043243243 0.043243243 bal&lt;-bal.tab(card_trim_comb.psid[[1]], data = all_trim.psid[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] -0.09900599 -0.08215316 0.03571429 0.01785714 -0.03571429 0.04464286 ## [7] -0.04356946 -0.09960598 0.04464286 -0.04464286 Profile matching # select the largest control group subset balanced to the treated group (for ATT), leaving the treated group intact profile_trim_comb.cps &lt;- attach_matchit(model, data_list = all_trim.cps, method = &quot;cardinality&quot;, estimand = &quot;ATT&quot;, tols = 0.1, ratio = NA, time = 1200) profile_trim_comb.psid &lt;- attach_matchit(model,data_list = all_trim.psid, method = &quot;cardinality&quot;, estimand = &quot;ATT&quot;, tols = 0.1, ratio = NA, time = 1200) names(match.data(profile_trim_comb.cps[[1]], data = all_trim.cps[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;weights&quot; names(match.data(profile_trim_comb.psid[[1]], data = all_trim.psid[[1]])) ## [1] &quot;data_id&quot; &quot;treat&quot; &quot;age&quot; &quot;education&quot; ## [5] &quot;black&quot; &quot;hispanic&quot; &quot;married&quot; &quot;nodegree&quot; ## [9] &quot;re74&quot; &quot;re75&quot; &quot;re78&quot; &quot;u74&quot; ## [13] &quot;u75&quot; &quot;sample&quot; &quot;ps_assoverlap&quot; &quot;weights&quot; bal&lt;-bal.tab(profile_trim_comb.cps[[1]], data = all_trim.cps[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] -0.09956021 -0.08372404 0.03467181 0.02231660 -0.03652510 0.04525097 ## [7] -0.02987200 -0.09937107 0.04525097 0.04857143 bal&lt;-bal.tab(profile_trim_comb.psid[[1]], data = all_trim.psid[[1]], stats = &quot;mean.diffs&quot;, un = TRUE, s.d.denom = &quot;treated&quot;) bal$Balance$Diff.Adj ## [1] -0.09626508 0.07470775 0.02917810 0.02181135 -0.03842265 0.01343348 ## [7] 0.05494433 -0.04393793 0.03668930 -0.01776686 1.5 Assessing methods We now systematically reassess all methods described above by evaluating the overlap coefficient (OVL) and the absolute standardized mean differences (ASMD). Specifically, we compute the ASMD and OVL for each approach and compute a composite score to determine the best performing methods. 1.5.1 Single methods 1.5.1.1 Trimming 1.5.1.1.1 SMD # compute absolute SMD smd_trim.cps &lt;- compute_abs_smd_trim(all_trim.cps, &quot;treat&quot;, covar) smd_trim.psid &lt;- compute_abs_smd_trim(all_trim.psid, &quot;treat&quot;, covar) 1.5.1.1.2 OVL # compute overlap coefficients ovl_trim.cps &lt;- compute_ovl_trim(all_trim.cps, &quot;ps_assoverlap&quot;, &quot;treat&quot;) ovl_trim.psid &lt;- compute_ovl_trim(all_trim.psid, &quot;ps_assoverlap&quot;, &quot;treat&quot;) 1.5.2 Integrated methods 1.5.2.1 Trimming and matching 1.5.2.1.1 Extended datasets (Similar to tutorial by Imbens and Xu (2024)) # list all trimmed and matched samples trim_match_comb.cps_plus &lt;- list(ps_threshold_match = ldw_cps.trim_match) trim_match_comb.psid_plus &lt;- list(ps_threshold_match = ldw_psid.trim_match) 1.5.2.1.1.1 SMD # compute absolute SMD smd_trim_match_comb.cps_plus &lt;- compute_abs_smd_trim(trim_match_comb.cps_plus, &quot;treat&quot;, covar) smd_trim_match_comb.psid_plus &lt;- compute_abs_smd_trim(trim_match_comb.psid_plus, &quot;treat&quot;, covar) 1.5.2.1.1.2 OVL # compute overlap coefficients ovl_trim_match_comb.cps_plus &lt;- compute_ovl_trim(trim_match_comb.cps_plus, &quot;ps_assoverlap&quot;, &quot;treat&quot;) ovl_trim_match_comb.psid_plus &lt;- compute_ovl_trim(trim_match_comb.psid_plus, &quot;ps_assoverlap&quot;, &quot;treat&quot;) 1.5.2.1.2 Initial datasets # list all trimmed and matched samples trim_match_comb.cps &lt;- list( nn = nn_trim_comb.cps, k2 = k2_trim_comb.cps, k3 = k3_trim_comb.cps, caliper = caliper_trim_comb.cps, cs = cs_trim_comb.cps, mahvars = mahvars_trim_comb.cps, optimal_pair = optimal_pair_trim_comb.cps, optimal_full = optimal_full_trim_comb.cps, genetic = genetic_trim_comb.cps, exact = exact_trim_comb.cps, cem = cem_trim_comb.cps, subcl = subcl_trim_comb.cps ) trim_match_comb.psid &lt;- list( nn = nn_trim_comb.psid, k2 = k2_trim_comb.psid, k3 = k3_trim_comb.psid, caliper = caliper_trim_comb.psid, cs = cs_trim_comb.psid, mahvars = mahvars_trim_comb.psid, optimal_pair = optimal_pair_trim_comb.psid, optimal_full = optimal_full_trim_comb.psid, genetic = genetic_trim_comb.psid, exact = exact_trim_comb.psid, cem = cem_trim_comb.psid, subcl = subcl_trim_comb.psid ) 1.5.2.1.2.1 SMD # compute absolute SMD smd_trim_match_comb.cps &lt;- compute_abs_smd_matchit(trim_match_comb.cps, all_trim.cps) smd_trim_match_comb.psid &lt;- compute_abs_smd_matchit(trim_match_comb.psid, all_trim.psid) smd_trim_match_comb.cps ## Method MatchIndex Mean_Abs_SMD Max_Abs_SMD ## 1 nn 1 3.061276e-02 1.134447e-01 ## 2 nn 2 3.061276e-02 1.134447e-01 ## 3 nn 3 3.719497e-01 1.608865e+00 ## 4 nn 4 3.078925e-01 1.324948e+00 ## 5 nn 5 3.261488e-02 1.004314e-01 ## 6 k2 1 3.622961e-02 1.196332e-01 ## 7 k2 2 3.622961e-02 1.196332e-01 ## 8 k2 3 1.971272e-01 6.624738e-01 ## 9 k2 4 1.929328e-01 8.990715e-01 ## 10 k2 5 2.704157e-02 8.427947e-02 ## 11 k3 1 4.274174e-02 1.254580e-01 ## 12 k3 2 4.274174e-02 1.254580e-01 ## 13 k3 3 1.477219e-01 5.993810e-01 ## 14 k3 4 2.202962e-01 7.571129e-01 ## 15 k3 5 2.589387e-02 9.257439e-02 ## 16 caliper 1 3.140821e-02 1.159518e-01 ## 17 caliper 2 3.140821e-02 1.159518e-01 ## 18 caliper 3 3.017284e-01 1.249236e+00 ## 19 caliper 4 2.312749e-01 9.369272e-01 ## 20 caliper 5 3.261488e-02 1.004314e-01 ## 21 cs 1 5.247216e-02 2.285129e-01 ## 22 cs 2 5.247216e-02 2.285129e-01 ## 23 cs 3 1.183383e-01 3.643606e-01 ## 24 cs 4 1.199312e-01 3.000000e-01 ## 25 cs 5 3.119386e-02 8.470343e-02 ## 26 mahvars 1 8.200879e-02 1.671024e-01 ## 27 mahvars 2 8.200879e-02 1.671024e-01 ## 28 mahvars 3 7.180904e-02 4.731955e-01 ## 29 mahvars 4 7.180904e-02 4.731955e-01 ## 30 mahvars 5 9.614256e-02 2.794858e-01 ## 31 optimal_pair 1 4.435500e-02 1.518496e-01 ## 32 optimal_pair 2 4.435500e-02 1.518496e-01 ## 33 optimal_pair 3 1.367490e-01 4.731955e-01 ## 34 optimal_pair 4 1.510551e-01 5.205151e-01 ## 35 optimal_pair 5 7.165699e-02 2.253764e-01 ## 36 optimal_full 1 2.592951e-02 1.251411e-01 ## 37 optimal_full 2 2.592951e-02 1.251411e-01 ## 38 optimal_full 3 1.018808e-01 3.883284e-01 ## 39 optimal_full 4 1.021585e-01 3.742204e-01 ## 40 optimal_full 5 2.830226e-02 9.448477e-02 ## 41 genetic 1 7.853186e-03 2.957225e-02 ## 42 genetic 2 8.940279e-03 2.957225e-02 ## 43 genetic 3 3.917660e-02 2.547540e-01 ## 44 genetic 4 3.920415e-02 2.550570e-01 ## 45 genetic 5 2.702088e-03 9.773472e-03 ## 46 exact 1 1.776357e-16 1.776357e-15 ## 47 exact 2 1.776357e-16 1.776357e-15 ## 48 exact 5 3.566591e-16 3.552714e-15 ## 49 cem 1 5.555001e-03 2.422462e-02 ## 50 cem 2 5.555001e-03 2.422462e-02 ## 51 cem 3 4.912529e-02 2.602575e-01 ## 52 cem 4 4.912529e-02 2.602575e-01 ## 53 cem 5 1.430870e-02 5.022776e-02 ## 54 subcl 1 1.408813e-01 5.509951e-01 ## 55 subcl 2 1.408813e-01 5.509951e-01 ## 56 subcl 3 1.112661e-01 2.459871e-01 ## 57 subcl 4 1.117927e-01 2.461324e-01 ## 58 subcl 5 3.445434e-02 1.886167e-01 smd_trim_match_comb.psid ## Method MatchIndex Mean_Abs_SMD Max_Abs_SMD ## 1 nn 1 1.348236e-01 3.504714e-01 ## 2 nn 2 1.146343e-01 2.943476e-01 ## 3 nn 3 1.083861e-01 2.756888e-01 ## 4 nn 4 1.399000e-01 3.481006e-01 ## 5 nn 5 1.078783e-01 3.816131e-01 ## 6 k2 1 1.002396e-01 2.868286e-01 ## 7 k2 2 8.328743e-02 1.977295e-01 ## 8 k2 3 2.222205e-01 6.902685e-01 ## 9 k2 4 1.010715e-01 3.432732e-01 ## 10 k2 5 7.542647e-02 2.694561e-01 ## 11 k3 1 8.797411e-02 2.801446e-01 ## 12 k3 2 7.753597e-02 2.130899e-01 ## 13 k3 3 2.128853e-01 7.158340e-01 ## 14 k3 4 1.227078e-01 5.518707e-01 ## 15 k3 5 6.589089e-02 2.410678e-01 ## 16 caliper 1 1.108480e-01 2.981431e-01 ## 17 caliper 2 1.069859e-01 2.848646e-01 ## 18 caliper 3 3.549771e-01 1.533930e+00 ## 19 caliper 4 1.526716e-01 5.835804e-01 ## 20 caliper 5 1.076659e-01 3.840102e-01 ## 21 cs 1 1.536404e-01 4.281958e-01 ## 22 cs 2 1.172394e-01 2.937601e-01 ## 23 cs 3 1.391226e-01 2.500000e-01 ## 24 cs 4 1.810905e-01 1.053370e+00 ## 25 cs 5 7.836697e-02 2.185048e-01 ## 26 mahvars 1 3.275547e-01 1.118908e+00 ## 27 mahvars 2 3.184691e-01 1.043257e+00 ## 28 mahvars 3 3.436844e-01 1.380537e+00 ## 29 mahvars 4 1.583646e-01 5.461920e-01 ## 30 mahvars 5 3.345337e-01 8.394438e-01 ## 31 optimal_pair 1 3.063730e-01 1.228568e+00 ## 32 optimal_pair 2 3.322829e-01 1.295104e+00 ## 33 optimal_pair 3 1.257979e-01 3.127652e-01 ## 34 optimal_pair 4 9.089509e-02 3.121097e-01 ## 35 optimal_pair 5 4.505981e-01 1.720607e+00 ## 36 optimal_full 1 1.161968e-01 3.009354e-01 ## 37 optimal_full 2 1.103353e-01 2.639413e-01 ## 38 optimal_full 3 2.080286e-01 7.902652e-01 ## 39 optimal_full 4 9.754673e-02 2.860421e-01 ## 40 optimal_full 5 9.373576e-02 2.962179e-01 ## 41 genetic 1 5.651842e-02 1.930063e-01 ## 42 genetic 2 4.463597e-02 1.525892e-01 ## 43 genetic 3 8.251659e-02 3.067860e-01 ## 44 genetic 4 7.654620e-02 3.083088e-01 ## 45 genetic 5 6.083359e-02 2.849757e-01 ## 46 exact 1 5.440093e-16 3.552714e-15 ## 47 exact 2 5.398459e-16 3.552714e-15 ## 48 exact 5 0.000000e+00 0.000000e+00 ## 49 cem 1 8.325733e-02 6.009392e-01 ## 50 cem 2 3.097718e-02 1.629897e-01 ## 51 cem 4 4.835874e-02 3.511234e-01 ## 52 cem 5 2.428539e-02 1.059102e-01 ## 53 subcl 1 2.655139e-01 1.062391e+00 ## 54 subcl 2 1.558704e-01 4.375556e-01 ## 55 subcl 3 2.080286e-01 7.902652e-01 ## 56 subcl 4 9.543299e-02 2.669895e-01 ## 57 subcl 5 1.176093e-01 2.840819e-01 1.5.2.1.2.2 OVL # compute overlap coefficients ovl_trim_match_comb.cps &lt;- compute_ovl_matchit(trim_match_comb.cps, all_trim.cps, ps = &quot;ps_assoverlap&quot;, treat = &quot;treat&quot;, covar = covar) ovl_trim_match_comb.psid &lt;- compute_ovl_matchit(trim_match_comb.psid, all_trim.psid, ps = &quot;ps_assoverlap&quot;, treat = &quot;treat&quot;, covar = covar) ovl_trim_match_comb.cps ## Method OVL ## 1 nn_1 0.6523269 ## 2 nn_2 0.6523269 ## 3 nn_3 0.3023320 ## 4 nn_4 0.3588358 ## 5 nn_5 0.7649104 ## 6 k2_1 0.6173957 ## 7 k2_2 0.6173957 ## 8 k2_3 0.4022629 ## 9 k2_4 0.4347274 ## 10 k2_5 0.7680589 ## 11 k3_1 0.5810221 ## 12 k3_2 0.5810221 ## 13 k3_3 0.4200277 ## 14 k3_4 0.4301151 ## 15 k3_5 0.7095130 ## 16 caliper_1 0.6606913 ## 17 caliper_2 0.6606913 ## 18 caliper_3 0.2584377 ## 19 caliper_4 0.3050616 ## 20 caliper_5 0.7649104 ## 21 cs_1 0.6707672 ## 22 cs_2 0.6707672 ## 23 cs_3 0.4058607 ## 24 cs_4 0.4089050 ## 25 cs_5 0.7851201 ## 26 mahvars_1 0.7352849 ## 27 mahvars_2 0.7352849 ## 28 mahvars_3 0.3598906 ## 29 mahvars_4 0.3446522 ## 30 mahvars_5 0.7594301 ## 31 optimal_pair_1 0.7211809 ## 32 optimal_pair_2 0.7211809 ## 33 optimal_pair_3 0.3957408 ## 34 optimal_pair_4 0.4250365 ## 35 optimal_pair_5 0.7632107 ## 36 optimal_full_1 0.3587450 ## 37 optimal_full_2 0.3587450 ## 38 optimal_full_3 0.4073559 ## 39 optimal_full_4 0.4204927 ## 40 optimal_full_5 0.6024890 ## 41 genetic_1 0.7466742 ## 42 genetic_2 0.7526742 ## 43 genetic_3 0.4103108 ## 44 genetic_4 0.4246558 ## 45 genetic_5 0.8402579 ## 46 exact_1 0.4702908 ## 47 exact_2 0.4702908 ## 48 exact_5 0.3428918 ## 49 cem_1 0.4664574 ## 50 cem_2 0.4664574 ## 51 cem_3 0.3480005 ## 52 cem_4 0.3362871 ## 53 cem_5 0.6960611 ## 54 subcl_1 0.3587450 ## 55 subcl_2 0.3587450 ## 56 subcl_3 0.4073559 ## 57 subcl_4 0.4204927 ## 58 subcl_5 0.6024890 1.6 Identifying best methods 1.6.1 Ranking To identify the top five methods for each observational dataset, we first combine for each dataset all results of the absolute SMD and OVL into a single data frame. This allows for a comprehensive comparison across all methods. Only results based on the non-plus datasets are included in the identification of the best methods, as the objective is to identify the overall best-performing methods for the original observational samples. # combine all results all_cps &lt;- combine_results(&quot;cps&quot;) all_psid &lt;- combine_results(&quot;psid&quot;) all_cps ## Method Mean_Abs_SMD Max_Abs_SMD OVL ## 1 ps_threshold 4.271568e-02 9.626508e-02 0.3587450 ## 2 common_range 4.271568e-02 9.626508e-02 0.3587450 ## 3 stuermer 4.271568e-02 9.626508e-02 0.4073559 ## 4 walker 4.271568e-02 9.626508e-02 0.4204927 ## 5 crump 4.271568e-02 9.626508e-02 0.6024890 ## 6 nn_1 3.061276e-02 1.134447e-01 0.6523269 ## 7 nn_2 3.061276e-02 1.134447e-01 0.6523269 ## 8 nn_3 3.719497e-01 1.608865e+00 0.3023320 ## 9 nn_4 3.078925e-01 1.324948e+00 0.3588358 ## 10 nn_5 3.261488e-02 1.004314e-01 0.7649104 ## 11 k2_1 3.622961e-02 1.196332e-01 0.6173957 ## 12 k2_2 3.622961e-02 1.196332e-01 0.6173957 ## 13 k2_3 1.971272e-01 6.624738e-01 0.4022629 ## 14 k2_4 1.929328e-01 8.990715e-01 0.4347274 ## 15 k2_5 2.704157e-02 8.427947e-02 0.7680589 ## 16 k3_1 4.274174e-02 1.254580e-01 0.5810221 ## 17 k3_2 4.274174e-02 1.254580e-01 0.5810221 ## 18 k3_3 1.477219e-01 5.993810e-01 0.4200277 ## 19 k3_4 2.202962e-01 7.571129e-01 0.4301151 ## 20 k3_5 2.589387e-02 9.257439e-02 0.7095130 ## 21 caliper_1 3.140821e-02 1.159518e-01 0.6606913 ## 22 caliper_2 3.140821e-02 1.159518e-01 0.6606913 ## 23 caliper_3 3.017284e-01 1.249236e+00 0.2584377 ## 24 caliper_4 2.312749e-01 9.369272e-01 0.3050616 ## 25 caliper_5 3.261488e-02 1.004314e-01 0.7649104 ## 26 cs_1 5.247216e-02 2.285129e-01 0.6707672 ## 27 cs_2 5.247216e-02 2.285129e-01 0.6707672 ## 28 cs_3 1.183383e-01 3.643606e-01 0.4058607 ## 29 cs_4 1.199312e-01 3.000000e-01 0.4089050 ## 30 cs_5 3.119386e-02 8.470343e-02 0.7851201 ## 31 mahvars_1 8.200879e-02 1.671024e-01 0.7352849 ## 32 mahvars_2 8.200879e-02 1.671024e-01 0.7352849 ## 33 mahvars_3 7.180904e-02 4.731955e-01 0.3598906 ## 34 mahvars_4 7.180904e-02 4.731955e-01 0.3446522 ## 35 mahvars_5 9.614256e-02 2.794858e-01 0.7594301 ## 36 optimal_pair_1 4.435500e-02 1.518496e-01 0.7211809 ## 37 optimal_pair_2 4.435500e-02 1.518496e-01 0.7211809 ## 38 optimal_pair_3 1.367490e-01 4.731955e-01 0.3957408 ## 39 optimal_pair_4 1.510551e-01 5.205151e-01 0.4250365 ## 40 optimal_pair_5 7.165699e-02 2.253764e-01 0.7632107 ## 41 optimal_full_1 2.592951e-02 1.251411e-01 0.3587450 ## 42 optimal_full_2 2.592951e-02 1.251411e-01 0.3587450 ## 43 optimal_full_3 1.018808e-01 3.883284e-01 0.4073559 ## 44 optimal_full_4 1.021585e-01 3.742204e-01 0.4204927 ## 45 optimal_full_5 2.830226e-02 9.448477e-02 0.6024890 ## 46 genetic_1 7.853186e-03 2.957225e-02 0.7466742 ## 47 genetic_2 8.940279e-03 2.957225e-02 0.7526742 ## 48 genetic_3 3.917660e-02 2.547540e-01 0.4103108 ## 49 genetic_4 3.920415e-02 2.550570e-01 0.4246558 ## 50 genetic_5 2.702088e-03 9.773472e-03 0.8402579 ## 51 exact_1 1.776357e-16 1.776357e-15 0.4702908 ## 52 exact_2 1.776357e-16 1.776357e-15 0.4702908 ## 53 exact_5 3.566591e-16 3.552714e-15 0.3428918 ## 54 cem_1 5.555001e-03 2.422462e-02 0.4664574 ## 55 cem_2 5.555001e-03 2.422462e-02 0.4664574 ## 56 cem_3 4.912529e-02 2.602575e-01 0.3480005 ## 57 cem_4 4.912529e-02 2.602575e-01 0.3362871 ## 58 cem_5 1.430870e-02 5.022776e-02 0.6960611 ## 59 subcl_1 1.408813e-01 5.509951e-01 0.3587450 ## 60 subcl_2 1.408813e-01 5.509951e-01 0.3587450 ## 61 subcl_3 1.112661e-01 2.459871e-01 0.4073559 ## 62 subcl_4 1.117927e-01 2.461324e-01 0.4204927 ## 63 subcl_5 3.445434e-02 1.886167e-01 0.6024890 # save results save_csv(all_cps, &quot;ldw_model_a_cps1_all_results&quot;) save_csv(all_psid, &quot;ldw_model_a_psid1_all_results&quot;) Next, each method is evaluated according to its OVL value. The top five methods are then selected based on the highest OVL values, with higher OVL values indicating better overlap between treated and control groups. # rank comparatively ranked_cps &lt;- assess_methods(all_cps) ranked_psid &lt;- assess_methods(all_psid) # get top 5 methods top5_methods.cps &lt;- get_top_methods(ranked_cps, top_n = 5) top5_methods.psid &lt;- get_top_methods(ranked_psid, top_n = 5) # rerank top 5 methods # print results top5_methods_df.cps &lt;- ranked_cps %&gt;% arrange(desc(OVL)) %&gt;% head(5) top5_methods_df.psid &lt;- ranked_psid %&gt;% arrange(desc(OVL)) %&gt;% head(5) datatable(top5_methods_df.cps, caption = &quot;Top 5 Methods for CPS1&quot;, options = list(scrollX = TRUE, paging = FALSE, pageLength = -1, searching = FALSE)) datatable(top5_methods_df.psid, caption = &quot;Top 5 Methods for PSID1&quot;, options = list(scrollX = TRUE, paging = FALSE, pageLength = -1, searching = FALSE)) 1.6.2 Dataset construction For the subsequent estimation, we need to construct datasets of the top‑ranked methods. Therefore, we match all method names back to their corresponding datasets, objects or vectors and construct corresponding datasets. trim_only_cps &lt;- list( ps_threshold = ldw_cps.ps_trim, common_range = ldw_cps.ps_common, stuermer = ldw_cps.ps_stuermer, walker = ldw_cps.ps_walker, crump = ldw_cps.ps_crump ) match_lookup_cps &lt;- c( wrap_match_entries(nn_trim_comb.cps, all_trim.cps, &quot;nn&quot;), wrap_match_entries(k2_trim_comb.cps, all_trim.cps, &quot;k2&quot;), wrap_match_entries(k3_trim_comb.cps, all_trim.cps, &quot;k3&quot;), wrap_match_entries(caliper_trim_comb.cps, all_trim.cps, &quot;caliper&quot;), wrap_match_entries(cs_trim_comb.cps, all_trim.cps, &quot;cs&quot;), wrap_match_entries(mahvars_trim_comb.cps, all_trim.cps, &quot;mahvars&quot;), wrap_match_entries(optimal_pair_trim_comb.cps, all_trim.cps, &quot;optimal_pair&quot;), wrap_match_entries(optimal_full_trim_comb.cps, all_trim.cps, &quot;optimal_full&quot;), wrap_match_entries(genetic_trim_comb.cps, all_trim.cps, &quot;genetic&quot;), wrap_match_entries(exact_trim_comb.cps, all_trim.cps, &quot;exact&quot;), wrap_match_entries(cem_trim_comb.cps, all_trim.cps, &quot;cem&quot;), wrap_match_entries(subcl_trim_comb.cps, all_trim.cps, &quot;subcl&quot;) ) trim_only_psid &lt;- list( ps_threshold = ldw_psid.ps_trim, common_range = ldw_psid.ps_common, stuermer = ldw_psid.ps_stuermer, walker = ldw_psid.ps_walker, crump = ldw_psid.ps_crump ) match_lookup_psid &lt;- c( wrap_match_entries(nn_trim_comb.psid, all_trim.psid, &quot;nn&quot;), wrap_match_entries(k2_trim_comb.psid, all_trim.psid, &quot;k2&quot;), wrap_match_entries(k3_trim_comb.psid, all_trim.psid, &quot;k3&quot;), wrap_match_entries(caliper_trim_comb.psid, all_trim.psid, &quot;caliper&quot;), wrap_match_entries(cs_trim_comb.psid, all_trim.psid, &quot;cs&quot;), wrap_match_entries(mahvars_trim_comb.psid, all_trim.psid, &quot;mahvars&quot;), wrap_match_entries(optimal_pair_trim_comb.psid, all_trim.psid, &quot;optimal_pair&quot;), wrap_match_entries(optimal_full_trim_comb.psid, all_trim.psid, &quot;optimal_full&quot;), wrap_match_entries(genetic_trim_comb.psid, all_trim.psid, &quot;genetic&quot;), wrap_match_entries(exact_trim_comb.psid, all_trim.psid, &quot;exact&quot;), wrap_match_entries(cem_trim_comb.psid, all_trim.psid, &quot;cem&quot;), wrap_match_entries(subcl_trim_comb.psid, all_trim.psid, &quot;subcl&quot;) ) list_cps &lt;- c(trim_only_cps, match_lookup_cps) list_psid &lt;- c(trim_only_psid, match_lookup_psid) # create datasets corresponding to the top 5 methods for each dataset top5_datasets.cps &lt;- create_top5_datasets(list_cps, top5_methods.cps) top5_datasets.psid &lt;- create_top5_datasets(list_psid, top5_methods.psid) # save datasets into .RData files save_top5_datasets(list_cps, top5_methods.cps, prefix = &quot;ldw_model_a_cps1&quot;) save_top5_datasets(list_psid, top5_methods.psid, prefix = &quot;ldw_model_a_psid1&quot;) 1.7 Estimating 1.7.1 Average treatment effect on the treated (ATT) Next, we estimate the average treatment effect on the treated (ATT) using the LDW-Experimental sample, the top‑ranked observational samples (LDW‑CPS1 and LDW‑PSID1), and, for comparison, the trimmed and matched plus‑datasets. We employ a broad set of estimators, including difference-in-means, regression, the Oaxaca-Blinder estimator, generalized random forests (GRF) as an outcome model, 1:5 nearest neighbor matching with bias correction, inverse probability weighting (IPW) with GRF-based propensity scores, covariate balancing propensity score (CBPS), entropy balancing, double/debiased machine learning using elastic net, and augmented inverse probability weighting (AIPW) via GRF. We also incorporate the recently introduced estimand-specific AIPW estimator implemented through an expansion of the OutcomeWeights R package by Knaus and Pfleiderer (2024). We utilize the estimate_all() and plot_coef() functions as defined by Imbens and Xu (2024). # estimate ATT out1 &lt;- estimate_all(ldw, &quot;re78&quot;, &quot;treat&quot;, covar) # out2 &lt;- estimate_all(ldw_cps, &quot;re78&quot;, &quot;treat&quot;, covar) # out3 &lt;- estimate_all(ldw_psid, &quot;re78&quot;, &quot;treat&quot;, covar) # out.cps &lt;- lapply(top5_datasets.cps, function(d) estimate_all(d, &quot;re78&quot;, &quot;treat&quot;, covar)) # out.psid &lt;- lapply(top5_datasets.psid, function(d) estimate_all(d, &quot;re78&quot;, &quot;treat&quot;, covar)) # out4 &lt;- out.cps[[1]] # out5 &lt;- out.cps[[2]] # out6 &lt;- out.cps[[3]] # out7 &lt;- out.cps[[4]] # out8 &lt;- out.cps[[5]] # out9 &lt;- out.psid[[1]] # out10 &lt;- out.psid[[2]] # out11 &lt;- out.psid[[3]] # out12 &lt;- out.psid[[4]] # out13 &lt;- out.psid[[5]] Greifer, Noah. 2025. “Matching Methods.” Imbens, Guido W., and Yiqing Xu. 2024. “LaLonde (1986) After Nearly Four Decades: Lessons Learned.” Knaus, Michael C., and Henri Pfleiderer. 2024. “Outcome Weights.” Stürmer, Til, Michael Webster-Clark, Jennifer L. Lund, Richard Wyss, Alan R. Ellis, Mark Lunt, Kenneth J. Rothman, and Robert J. Glynn. 2021. “Propensity Score Weighting and Trimming Strategies for Reducing Variance and Bias of Treatment Effect Estimates: A Simulation Study.” American Journal of Epidemiology. References Greifer, Noah. 2025. “Matching Methods.” Imbens, Guido W., and Yiqing Xu. 2024. “LaLonde (1986) After Nearly Four Decades: Lessons Learned.” Knaus, Michael C., and Henri Pfleiderer. 2024. “Outcome Weights.” Stürmer, Til, Michael Webster-Clark, Jennifer L. Lund, Richard Wyss, Alan R. Ellis, Mark Lunt, Kenneth J. Rothman, and Robert J. Glynn. 2021. “Propensity Score Weighting and Trimming Strategies for Reducing Variance and Bias of Treatment Effect Estimates: A Simulation Study.” American Journal of Epidemiology. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
